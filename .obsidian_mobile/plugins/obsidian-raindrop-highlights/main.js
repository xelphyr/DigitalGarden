/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/nunjucks/browser/nunjucks.js
var require_nunjucks = __commonJS({
  "node_modules/nunjucks/browser/nunjucks.js"(exports, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["nunjucks"] = factory();
      else
        root["nunjucks"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            i: moduleId,
            l: false,
            exports: {}
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, {
              configurable: false,
              enumerable: true,
              get: getter
            });
          }
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? function getDefault() {
            return module3["default"];
          } : function getModuleExports() {
            return module3;
          };
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 11);
      }([
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var ArrayProto = Array.prototype;
          var ObjProto = Object.prototype;
          var escapeMap = {
            "&": "&amp;",
            '"': "&quot;",
            "'": "&#39;",
            "<": "&lt;",
            ">": "&gt;",
            "\\": "&#92;"
          };
          var escapeRegex = /[&"'<>\\]/g;
          var exports2 = module3.exports = {};
          function hasOwnProp(obj, k) {
            return ObjProto.hasOwnProperty.call(obj, k);
          }
          exports2.hasOwnProp = hasOwnProp;
          function lookupEscape(ch) {
            return escapeMap[ch];
          }
          function _prettifyError(path, withInternals, err) {
            if (!err.Update) {
              err = new exports2.TemplateError(err);
            }
            err.Update(path);
            if (!withInternals) {
              var old = err;
              err = new Error(old.message);
              err.name = old.name;
            }
            return err;
          }
          exports2._prettifyError = _prettifyError;
          function TemplateError(message, lineno, colno) {
            var err;
            var cause;
            if (message instanceof Error) {
              cause = message;
              message = cause.name + ": " + cause.message;
            }
            if (Object.setPrototypeOf) {
              err = new Error(message);
              Object.setPrototypeOf(err, TemplateError.prototype);
            } else {
              err = this;
              Object.defineProperty(err, "message", {
                enumerable: false,
                writable: true,
                value: message
              });
            }
            Object.defineProperty(err, "name", {
              value: "Template render error"
            });
            if (Error.captureStackTrace) {
              Error.captureStackTrace(err, this.constructor);
            }
            var getStack;
            if (cause) {
              var stackDescriptor = Object.getOwnPropertyDescriptor(cause, "stack");
              getStack = stackDescriptor && (stackDescriptor.get || function() {
                return stackDescriptor.value;
              });
              if (!getStack) {
                getStack = function getStack2() {
                  return cause.stack;
                };
              }
            } else {
              var stack = new Error(message).stack;
              getStack = function getStack2() {
                return stack;
              };
            }
            Object.defineProperty(err, "stack", {
              get: function get() {
                return getStack.call(err);
              }
            });
            Object.defineProperty(err, "cause", {
              value: cause
            });
            err.lineno = lineno;
            err.colno = colno;
            err.firstUpdate = true;
            err.Update = function Update(path) {
              var msg = "(" + (path || "unknown path") + ")";
              if (this.firstUpdate) {
                if (this.lineno && this.colno) {
                  msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
                } else if (this.lineno) {
                  msg += " [Line " + this.lineno + "]";
                }
              }
              msg += "\n ";
              if (this.firstUpdate) {
                msg += " ";
              }
              this.message = msg + (this.message || "");
              this.firstUpdate = false;
              return this;
            };
            return err;
          }
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
          } else {
            TemplateError.prototype = Object.create(Error.prototype, {
              constructor: {
                value: TemplateError
              }
            });
          }
          exports2.TemplateError = TemplateError;
          function escape(val) {
            return val.replace(escapeRegex, lookupEscape);
          }
          exports2.escape = escape;
          function isFunction(obj) {
            return ObjProto.toString.call(obj) === "[object Function]";
          }
          exports2.isFunction = isFunction;
          function isArray(obj) {
            return ObjProto.toString.call(obj) === "[object Array]";
          }
          exports2.isArray = isArray;
          function isString(obj) {
            return ObjProto.toString.call(obj) === "[object String]";
          }
          exports2.isString = isString;
          function isObject(obj) {
            return ObjProto.toString.call(obj) === "[object Object]";
          }
          exports2.isObject = isObject;
          function _prepareAttributeParts(attr2) {
            if (!attr2) {
              return [];
            }
            if (typeof attr2 === "string") {
              return attr2.split(".");
            }
            return [attr2];
          }
          function getAttrGetter(attribute) {
            var parts = _prepareAttributeParts(attribute);
            return function attrGetter(item) {
              var _item = item;
              for (var i = 0; i < parts.length; i++) {
                var part = parts[i];
                if (hasOwnProp(_item, part)) {
                  _item = _item[part];
                } else {
                  return void 0;
                }
              }
              return _item;
            };
          }
          exports2.getAttrGetter = getAttrGetter;
          function groupBy(obj, val, throwOnUndefined) {
            var result = {};
            var iterator = isFunction(val) ? val : getAttrGetter(val);
            for (var i = 0; i < obj.length; i++) {
              var value = obj[i];
              var key = iterator(value, i);
              if (key === void 0 && throwOnUndefined === true) {
                throw new TypeError('groupby: attribute "' + val + '" resolved to undefined');
              }
              (result[key] || (result[key] = [])).push(value);
            }
            return result;
          }
          exports2.groupBy = groupBy;
          function toArray(obj) {
            return Array.prototype.slice.call(obj);
          }
          exports2.toArray = toArray;
          function without(array) {
            var result = [];
            if (!array) {
              return result;
            }
            var length = array.length;
            var contains = toArray(arguments).slice(1);
            var index = -1;
            while (++index < length) {
              if (indexOf(contains, array[index]) === -1) {
                result.push(array[index]);
              }
            }
            return result;
          }
          exports2.without = without;
          function repeat(char_, n) {
            var str = "";
            for (var i = 0; i < n; i++) {
              str += char_;
            }
            return str;
          }
          exports2.repeat = repeat;
          function each(obj, func, context) {
            if (obj == null) {
              return;
            }
            if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
              obj.forEach(func, context);
            } else if (obj.length === +obj.length) {
              for (var i = 0, l = obj.length; i < l; i++) {
                func.call(context, obj[i], i, obj);
              }
            }
          }
          exports2.each = each;
          function map(obj, func) {
            var results = [];
            if (obj == null) {
              return results;
            }
            if (ArrayProto.map && obj.map === ArrayProto.map) {
              return obj.map(func);
            }
            for (var i = 0; i < obj.length; i++) {
              results[results.length] = func(obj[i], i);
            }
            if (obj.length === +obj.length) {
              results.length = obj.length;
            }
            return results;
          }
          exports2.map = map;
          function asyncIter(arr, iter, cb) {
            var i = -1;
            function next() {
              i++;
              if (i < arr.length) {
                iter(arr[i], i, next, cb);
              } else {
                cb();
              }
            }
            next();
          }
          exports2.asyncIter = asyncIter;
          function asyncFor(obj, iter, cb) {
            var keys = keys_(obj || {});
            var len = keys.length;
            var i = -1;
            function next() {
              i++;
              var k = keys[i];
              if (i < len) {
                iter(k, obj[k], i, len, next);
              } else {
                cb();
              }
            }
            next();
          }
          exports2.asyncFor = asyncFor;
          function indexOf(arr, searchElement, fromIndex) {
            return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
          }
          exports2.indexOf = indexOf;
          function keys_(obj) {
            var arr = [];
            for (var k in obj) {
              if (hasOwnProp(obj, k)) {
                arr.push(k);
              }
            }
            return arr;
          }
          exports2.keys = keys_;
          function _entries(obj) {
            return keys_(obj).map(function(k) {
              return [k, obj[k]];
            });
          }
          exports2._entries = _entries;
          function _values(obj) {
            return keys_(obj).map(function(k) {
              return obj[k];
            });
          }
          exports2._values = _values;
          function extend(obj1, obj2) {
            obj1 = obj1 || {};
            keys_(obj2).forEach(function(k) {
              obj1[k] = obj2[k];
            });
            return obj1;
          }
          exports2._assign = exports2.extend = extend;
          function inOperator(key, val) {
            if (isArray(val) || isString(val)) {
              return val.indexOf(key) !== -1;
            } else if (isObject(val)) {
              return key in val;
            }
            throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
          }
          exports2.inOperator = inOperator;
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            Object.defineProperty(Constructor, "prototype", { writable: false });
            return Constructor;
          }
          function _toPropertyKey(arg) {
            var key = _toPrimitive(arg, "string");
            return typeof key === "symbol" ? key : String(key);
          }
          function _toPrimitive(input, hint) {
            if (typeof input !== "object" || input === null)
              return input;
            var prim = input[Symbol.toPrimitive];
            if (prim !== void 0) {
              var res = prim.call(input, hint || "default");
              if (typeof res !== "object")
                return res;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (hint === "string" ? String : Number)(input);
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          var EventEmitter = __webpack_require__(16);
          var lib = __webpack_require__(0);
          function parentWrap(parent, prop) {
            if (typeof parent !== "function" || typeof prop !== "function") {
              return prop;
            }
            return function wrap() {
              var tmp = this.parent;
              this.parent = parent;
              var res = prop.apply(this, arguments);
              this.parent = tmp;
              return res;
            };
          }
          function extendClass(cls, name, props) {
            props = props || {};
            lib.keys(props).forEach(function(k) {
              props[k] = parentWrap(cls.prototype[k], props[k]);
            });
            var subclass = /* @__PURE__ */ function(_cls) {
              _inheritsLoose(subclass2, _cls);
              function subclass2() {
                return _cls.apply(this, arguments) || this;
              }
              _createClass(subclass2, [{
                key: "typename",
                get: function get() {
                  return name;
                }
              }]);
              return subclass2;
            }(cls);
            lib._assign(subclass.prototype, props);
            return subclass;
          }
          var Obj = /* @__PURE__ */ function() {
            function Obj2() {
              this.init.apply(this, arguments);
            }
            var _proto = Obj2.prototype;
            _proto.init = function init2() {
            };
            Obj2.extend = function extend(name, props) {
              if (typeof name === "object") {
                props = name;
                name = "anonymous";
              }
              return extendClass(this, name, props);
            };
            _createClass(Obj2, [{
              key: "typename",
              get: function get() {
                return this.constructor.name;
              }
            }]);
            return Obj2;
          }();
          var EmitterObj = /* @__PURE__ */ function(_EventEmitter) {
            _inheritsLoose(EmitterObj2, _EventEmitter);
            function EmitterObj2() {
              var _this2;
              var _this;
              _this = _EventEmitter.call(this) || this;
              (_this2 = _this).init.apply(_this2, arguments);
              return _this;
            }
            var _proto2 = EmitterObj2.prototype;
            _proto2.init = function init2() {
            };
            EmitterObj2.extend = function extend(name, props) {
              if (typeof name === "object") {
                props = name;
                name = "anonymous";
              }
              return extendClass(this, name, props);
            };
            _createClass(EmitterObj2, [{
              key: "typename",
              get: function get() {
                return this.constructor.name;
              }
            }]);
            return EmitterObj2;
          }(EventEmitter);
          module3.exports = {
            Obj,
            EmitterObj
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var lib = __webpack_require__(0);
          var arrayFrom = Array.from;
          var supportsIterators = typeof Symbol === "function" && Symbol.iterator && typeof arrayFrom === "function";
          var Frame = /* @__PURE__ */ function() {
            function Frame2(parent, isolateWrites) {
              this.variables = /* @__PURE__ */ Object.create(null);
              this.parent = parent;
              this.topLevel = false;
              this.isolateWrites = isolateWrites;
            }
            var _proto = Frame2.prototype;
            _proto.set = function set(name, val, resolveUp) {
              var parts = name.split(".");
              var obj = this.variables;
              var frame = this;
              if (resolveUp) {
                if (frame = this.resolve(parts[0], true)) {
                  frame.set(name, val);
                  return;
                }
              }
              for (var i = 0; i < parts.length - 1; i++) {
                var id = parts[i];
                if (!obj[id]) {
                  obj[id] = {};
                }
                obj = obj[id];
              }
              obj[parts[parts.length - 1]] = val;
            };
            _proto.get = function get(name) {
              var val = this.variables[name];
              if (val !== void 0) {
                return val;
              }
              return null;
            };
            _proto.lookup = function lookup(name) {
              var p = this.parent;
              var val = this.variables[name];
              if (val !== void 0) {
                return val;
              }
              return p && p.lookup(name);
            };
            _proto.resolve = function resolve(name, forWrite) {
              var p = forWrite && this.isolateWrites ? void 0 : this.parent;
              var val = this.variables[name];
              if (val !== void 0) {
                return this;
              }
              return p && p.resolve(name);
            };
            _proto.push = function push(isolateWrites) {
              return new Frame2(this, isolateWrites);
            };
            _proto.pop = function pop() {
              return this.parent;
            };
            return Frame2;
          }();
          function makeMacro(argNames, kwargNames, func) {
            return function macro() {
              for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
                macroArgs[_key] = arguments[_key];
              }
              var argCount = numArgs(macroArgs);
              var args;
              var kwargs = getKeywordArgs(macroArgs);
              if (argCount > argNames.length) {
                args = macroArgs.slice(0, argNames.length);
                macroArgs.slice(args.length, argCount).forEach(function(val, i2) {
                  if (i2 < kwargNames.length) {
                    kwargs[kwargNames[i2]] = val;
                  }
                });
                args.push(kwargs);
              } else if (argCount < argNames.length) {
                args = macroArgs.slice(0, argCount);
                for (var i = argCount; i < argNames.length; i++) {
                  var arg = argNames[i];
                  args.push(kwargs[arg]);
                  delete kwargs[arg];
                }
                args.push(kwargs);
              } else {
                args = macroArgs;
              }
              return func.apply(this, args);
            };
          }
          function makeKeywordArgs(obj) {
            obj.__keywords = true;
            return obj;
          }
          function isKeywordArgs(obj) {
            return obj && Object.prototype.hasOwnProperty.call(obj, "__keywords");
          }
          function getKeywordArgs(args) {
            var len = args.length;
            if (len) {
              var lastArg = args[len - 1];
              if (isKeywordArgs(lastArg)) {
                return lastArg;
              }
            }
            return {};
          }
          function numArgs(args) {
            var len = args.length;
            if (len === 0) {
              return 0;
            }
            var lastArg = args[len - 1];
            if (isKeywordArgs(lastArg)) {
              return len - 1;
            } else {
              return len;
            }
          }
          function SafeString(val) {
            if (typeof val !== "string") {
              return val;
            }
            this.val = val;
            this.length = val.length;
          }
          SafeString.prototype = Object.create(String.prototype, {
            length: {
              writable: true,
              configurable: true,
              value: 0
            }
          });
          SafeString.prototype.valueOf = function valueOf() {
            return this.val;
          };
          SafeString.prototype.toString = function toString() {
            return this.val;
          };
          function copySafeness(dest, target) {
            if (dest instanceof SafeString) {
              return new SafeString(target);
            }
            return target.toString();
          }
          function markSafe(val) {
            var type = typeof val;
            if (type === "string") {
              return new SafeString(val);
            } else if (type !== "function") {
              return val;
            } else {
              return function wrapSafe(args) {
                var ret = val.apply(this, arguments);
                if (typeof ret === "string") {
                  return new SafeString(ret);
                }
                return ret;
              };
            }
          }
          function suppressValue(val, autoescape) {
            val = val !== void 0 && val !== null ? val : "";
            if (autoescape && !(val instanceof SafeString)) {
              val = lib.escape(val.toString());
            }
            return val;
          }
          function ensureDefined(val, lineno, colno) {
            if (val === null || val === void 0) {
              throw new lib.TemplateError("attempted to output null or undefined value", lineno + 1, colno + 1);
            }
            return val;
          }
          function memberLookup(obj, val) {
            if (obj === void 0 || obj === null) {
              return void 0;
            }
            if (typeof obj[val] === "function") {
              return function() {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }
                return obj[val].apply(obj, args);
              };
            }
            return obj[val];
          }
          function callWrap(obj, name, context, args) {
            if (!obj) {
              throw new Error("Unable to call `" + name + "`, which is undefined or falsey");
            } else if (typeof obj !== "function") {
              throw new Error("Unable to call `" + name + "`, which is not a function");
            }
            return obj.apply(context, args);
          }
          function contextOrFrameLookup(context, frame, name) {
            var val = frame.lookup(name);
            return val !== void 0 ? val : context.lookup(name);
          }
          function handleError(error, lineno, colno) {
            if (error.lineno) {
              return error;
            } else {
              return new lib.TemplateError(error, lineno, colno);
            }
          }
          function asyncEach(arr, dimen, iter, cb) {
            if (lib.isArray(arr)) {
              var len = arr.length;
              lib.asyncIter(arr, function iterCallback(item, i, next) {
                switch (dimen) {
                  case 1:
                    iter(item, i, len, next);
                    break;
                  case 2:
                    iter(item[0], item[1], i, len, next);
                    break;
                  case 3:
                    iter(item[0], item[1], item[2], i, len, next);
                    break;
                  default:
                    item.push(i, len, next);
                    iter.apply(this, item);
                }
              }, cb);
            } else {
              lib.asyncFor(arr, function iterCallback(key, val, i, len2, next) {
                iter(key, val, i, len2, next);
              }, cb);
            }
          }
          function asyncAll(arr, dimen, func, cb) {
            var finished = 0;
            var len;
            var outputArr;
            function done(i2, output) {
              finished++;
              outputArr[i2] = output;
              if (finished === len) {
                cb(null, outputArr.join(""));
              }
            }
            if (lib.isArray(arr)) {
              len = arr.length;
              outputArr = new Array(len);
              if (len === 0) {
                cb(null, "");
              } else {
                for (var i = 0; i < arr.length; i++) {
                  var item = arr[i];
                  switch (dimen) {
                    case 1:
                      func(item, i, len, done);
                      break;
                    case 2:
                      func(item[0], item[1], i, len, done);
                      break;
                    case 3:
                      func(item[0], item[1], item[2], i, len, done);
                      break;
                    default:
                      item.push(i, len, done);
                      func.apply(this, item);
                  }
                }
              }
            } else {
              var keys = lib.keys(arr || {});
              len = keys.length;
              outputArr = new Array(len);
              if (len === 0) {
                cb(null, "");
              } else {
                for (var _i = 0; _i < keys.length; _i++) {
                  var k = keys[_i];
                  func(k, arr[k], _i, len, done);
                }
              }
            }
          }
          function fromIterator(arr) {
            if (typeof arr !== "object" || arr === null || lib.isArray(arr)) {
              return arr;
            } else if (supportsIterators && Symbol.iterator in arr) {
              return arrayFrom(arr);
            } else {
              return arr;
            }
          }
          module3.exports = {
            Frame,
            makeMacro,
            makeKeywordArgs,
            numArgs,
            suppressValue,
            ensureDefined,
            memberLookup,
            contextOrFrameLookup,
            callWrap,
            handleError,
            isArray: lib.isArray,
            keys: lib.keys,
            SafeString,
            copySafeness,
            markSafe,
            asyncEach,
            asyncAll,
            inOperator: lib.inOperator,
            fromIterator
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            Object.defineProperty(Constructor, "prototype", { writable: false });
            return Constructor;
          }
          function _toPropertyKey(arg) {
            var key = _toPrimitive(arg, "string");
            return typeof key === "symbol" ? key : String(key);
          }
          function _toPrimitive(input, hint) {
            if (typeof input !== "object" || input === null)
              return input;
            var prim = input[Symbol.toPrimitive];
            if (prim !== void 0) {
              var res = prim.call(input, hint || "default");
              if (typeof res !== "object")
                return res;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (hint === "string" ? String : Number)(input);
          }
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          var _require = __webpack_require__(1), Obj = _require.Obj;
          function traverseAndCheck(obj, type, results) {
            if (obj instanceof type) {
              results.push(obj);
            }
            if (obj instanceof Node) {
              obj.findAll(type, results);
            }
          }
          var Node = /* @__PURE__ */ function(_Obj) {
            _inheritsLoose(Node2, _Obj);
            function Node2() {
              return _Obj.apply(this, arguments) || this;
            }
            var _proto = Node2.prototype;
            _proto.init = function init2(lineno, colno) {
              var _arguments = arguments, _this = this;
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              this.lineno = lineno;
              this.colno = colno;
              this.fields.forEach(function(field, i) {
                var val = _arguments[i + 2];
                if (val === void 0) {
                  val = null;
                }
                _this[field] = val;
              });
            };
            _proto.findAll = function findAll(type, results) {
              var _this2 = this;
              results = results || [];
              if (this instanceof NodeList) {
                this.children.forEach(function(child) {
                  return traverseAndCheck(child, type, results);
                });
              } else {
                this.fields.forEach(function(field) {
                  return traverseAndCheck(_this2[field], type, results);
                });
              }
              return results;
            };
            _proto.iterFields = function iterFields(func) {
              var _this3 = this;
              this.fields.forEach(function(field) {
                func(_this3[field], field);
              });
            };
            return Node2;
          }(Obj);
          var Value = /* @__PURE__ */ function(_Node) {
            _inheritsLoose(Value2, _Node);
            function Value2() {
              return _Node.apply(this, arguments) || this;
            }
            _createClass(Value2, [{
              key: "typename",
              get: function get() {
                return "Value";
              }
            }, {
              key: "fields",
              get: function get() {
                return ["value"];
              }
            }]);
            return Value2;
          }(Node);
          var NodeList = /* @__PURE__ */ function(_Node2) {
            _inheritsLoose(NodeList2, _Node2);
            function NodeList2() {
              return _Node2.apply(this, arguments) || this;
            }
            var _proto2 = NodeList2.prototype;
            _proto2.init = function init2(lineno, colno, nodes) {
              _Node2.prototype.init.call(this, lineno, colno, nodes || []);
            };
            _proto2.addChild = function addChild(node) {
              this.children.push(node);
            };
            _createClass(NodeList2, [{
              key: "typename",
              get: function get() {
                return "NodeList";
              }
            }, {
              key: "fields",
              get: function get() {
                return ["children"];
              }
            }]);
            return NodeList2;
          }(Node);
          var Root = NodeList.extend("Root");
          var Literal = Value.extend("Literal");
          var _Symbol = Value.extend("Symbol");
          var Group = NodeList.extend("Group");
          var ArrayNode = NodeList.extend("Array");
          var Pair = Node.extend("Pair", {
            fields: ["key", "value"]
          });
          var Dict = NodeList.extend("Dict");
          var LookupVal = Node.extend("LookupVal", {
            fields: ["target", "val"]
          });
          var If = Node.extend("If", {
            fields: ["cond", "body", "else_"]
          });
          var IfAsync = If.extend("IfAsync");
          var InlineIf = Node.extend("InlineIf", {
            fields: ["cond", "body", "else_"]
          });
          var For = Node.extend("For", {
            fields: ["arr", "name", "body", "else_"]
          });
          var AsyncEach = For.extend("AsyncEach");
          var AsyncAll = For.extend("AsyncAll");
          var Macro = Node.extend("Macro", {
            fields: ["name", "args", "body"]
          });
          var Caller = Macro.extend("Caller");
          var Import = Node.extend("Import", {
            fields: ["template", "target", "withContext"]
          });
          var FromImport = /* @__PURE__ */ function(_Node3) {
            _inheritsLoose(FromImport2, _Node3);
            function FromImport2() {
              return _Node3.apply(this, arguments) || this;
            }
            var _proto3 = FromImport2.prototype;
            _proto3.init = function init2(lineno, colno, template, names, withContext) {
              _Node3.prototype.init.call(this, lineno, colno, template, names || new NodeList(), withContext);
            };
            _createClass(FromImport2, [{
              key: "typename",
              get: function get() {
                return "FromImport";
              }
            }, {
              key: "fields",
              get: function get() {
                return ["template", "names", "withContext"];
              }
            }]);
            return FromImport2;
          }(Node);
          var FunCall = Node.extend("FunCall", {
            fields: ["name", "args"]
          });
          var Filter = FunCall.extend("Filter");
          var FilterAsync = Filter.extend("FilterAsync", {
            fields: ["name", "args", "symbol"]
          });
          var KeywordArgs = Dict.extend("KeywordArgs");
          var Block = Node.extend("Block", {
            fields: ["name", "body"]
          });
          var Super = Node.extend("Super", {
            fields: ["blockName", "symbol"]
          });
          var TemplateRef = Node.extend("TemplateRef", {
            fields: ["template"]
          });
          var Extends = TemplateRef.extend("Extends");
          var Include = Node.extend("Include", {
            fields: ["template", "ignoreMissing"]
          });
          var Set2 = Node.extend("Set", {
            fields: ["targets", "value"]
          });
          var Switch = Node.extend("Switch", {
            fields: ["expr", "cases", "default"]
          });
          var Case = Node.extend("Case", {
            fields: ["cond", "body"]
          });
          var Output = NodeList.extend("Output");
          var Capture = Node.extend("Capture", {
            fields: ["body"]
          });
          var TemplateData = Literal.extend("TemplateData");
          var UnaryOp = Node.extend("UnaryOp", {
            fields: ["target"]
          });
          var BinOp = Node.extend("BinOp", {
            fields: ["left", "right"]
          });
          var In = BinOp.extend("In");
          var Is = BinOp.extend("Is");
          var Or = BinOp.extend("Or");
          var And = BinOp.extend("And");
          var Not = UnaryOp.extend("Not");
          var Add = BinOp.extend("Add");
          var Concat = BinOp.extend("Concat");
          var Sub = BinOp.extend("Sub");
          var Mul = BinOp.extend("Mul");
          var Div = BinOp.extend("Div");
          var FloorDiv = BinOp.extend("FloorDiv");
          var Mod = BinOp.extend("Mod");
          var Pow = BinOp.extend("Pow");
          var Neg = UnaryOp.extend("Neg");
          var Pos = UnaryOp.extend("Pos");
          var Compare = Node.extend("Compare", {
            fields: ["expr", "ops"]
          });
          var CompareOperand = Node.extend("CompareOperand", {
            fields: ["expr", "type"]
          });
          var CallExtension = Node.extend("CallExtension", {
            init: function init2(ext, prop, args, contentArgs) {
              this.parent();
              this.extName = ext.__name || ext;
              this.prop = prop;
              this.args = args || new NodeList();
              this.contentArgs = contentArgs || [];
              this.autoescape = ext.autoescape;
            },
            fields: ["extName", "prop", "args", "contentArgs"]
          });
          var CallExtensionAsync = CallExtension.extend("CallExtensionAsync");
          function print(str, indent, inline) {
            var lines = str.split("\n");
            lines.forEach(function(line, i) {
              if (line && (inline && i > 0 || !inline)) {
                process.stdout.write(" ".repeat(indent));
              }
              var nl = i === lines.length - 1 ? "" : "\n";
              process.stdout.write("" + line + nl);
            });
          }
          function printNodes(node, indent) {
            indent = indent || 0;
            print(node.typename + ": ", indent);
            if (node instanceof NodeList) {
              print("\n");
              node.children.forEach(function(n) {
                printNodes(n, indent + 2);
              });
            } else if (node instanceof CallExtension) {
              print(node.extName + "." + node.prop + "\n");
              if (node.args) {
                printNodes(node.args, indent + 2);
              }
              if (node.contentArgs) {
                node.contentArgs.forEach(function(n) {
                  printNodes(n, indent + 2);
                });
              }
            } else {
              var nodes = [];
              var props = null;
              node.iterFields(function(val, fieldName) {
                if (val instanceof Node) {
                  nodes.push([fieldName, val]);
                } else {
                  props = props || {};
                  props[fieldName] = val;
                }
              });
              if (props) {
                print(JSON.stringify(props, null, 2) + "\n", null, true);
              } else {
                print("\n");
              }
              nodes.forEach(function(_ref) {
                var fieldName = _ref[0], n = _ref[1];
                print("[" + fieldName + "] =>", indent + 2);
                printNodes(n, indent + 4);
              });
            }
          }
          module3.exports = {
            Node,
            Root,
            NodeList,
            Value,
            Literal,
            Symbol: _Symbol,
            Group,
            Array: ArrayNode,
            Pair,
            Dict,
            Output,
            Capture,
            TemplateData,
            If,
            IfAsync,
            InlineIf,
            For,
            AsyncEach,
            AsyncAll,
            Macro,
            Caller,
            Import,
            FromImport,
            FunCall,
            Filter,
            FilterAsync,
            KeywordArgs,
            Block,
            Super,
            Extends,
            Include,
            Set: Set2,
            Switch,
            Case,
            LookupVal,
            BinOp,
            In,
            Is,
            Or,
            And,
            Not,
            Add,
            Concat,
            Sub,
            Mul,
            Div,
            FloorDiv,
            Mod,
            Pow,
            Neg,
            Pos,
            Compare,
            CompareOperand,
            CallExtension,
            CallExtensionAsync,
            printNodes
          };
        },
        function(module3, exports2) {
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          var parser = __webpack_require__(8);
          var transformer = __webpack_require__(17);
          var nodes = __webpack_require__(3);
          var _require = __webpack_require__(0), TemplateError = _require.TemplateError;
          var _require2 = __webpack_require__(2), Frame = _require2.Frame;
          var _require3 = __webpack_require__(1), Obj = _require3.Obj;
          var compareOps = {
            "==": "==",
            "===": "===",
            "!=": "!=",
            "!==": "!==",
            "<": "<",
            ">": ">",
            "<=": "<=",
            ">=": ">="
          };
          var Compiler = /* @__PURE__ */ function(_Obj) {
            _inheritsLoose(Compiler2, _Obj);
            function Compiler2() {
              return _Obj.apply(this, arguments) || this;
            }
            var _proto = Compiler2.prototype;
            _proto.init = function init2(templateName, throwOnUndefined) {
              this.templateName = templateName;
              this.codebuf = [];
              this.lastId = 0;
              this.buffer = null;
              this.bufferStack = [];
              this._scopeClosers = "";
              this.inBlock = false;
              this.throwOnUndefined = throwOnUndefined;
            };
            _proto.fail = function fail(msg, lineno, colno) {
              if (lineno !== void 0) {
                lineno += 1;
              }
              if (colno !== void 0) {
                colno += 1;
              }
              throw new TemplateError(msg, lineno, colno);
            };
            _proto._pushBuffer = function _pushBuffer() {
              var id = this._tmpid();
              this.bufferStack.push(this.buffer);
              this.buffer = id;
              this._emit("var " + this.buffer + ' = "";');
              return id;
            };
            _proto._popBuffer = function _popBuffer() {
              this.buffer = this.bufferStack.pop();
            };
            _proto._emit = function _emit(code) {
              this.codebuf.push(code);
            };
            _proto._emitLine = function _emitLine(code) {
              this._emit(code + "\n");
            };
            _proto._emitLines = function _emitLines() {
              var _this = this;
              for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
                lines[_key] = arguments[_key];
              }
              lines.forEach(function(line) {
                return _this._emitLine(line);
              });
            };
            _proto._emitFuncBegin = function _emitFuncBegin(node, name) {
              this.buffer = "output";
              this._scopeClosers = "";
              this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");
              this._emitLine("var lineno = " + node.lineno + ";");
              this._emitLine("var colno = " + node.colno + ";");
              this._emitLine("var " + this.buffer + ' = "";');
              this._emitLine("try {");
            };
            _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
              if (!noReturn) {
                this._emitLine("cb(null, " + this.buffer + ");");
              }
              this._closeScopeLevels();
              this._emitLine("} catch (e) {");
              this._emitLine("  cb(runtime.handleError(e, lineno, colno));");
              this._emitLine("}");
              this._emitLine("}");
              this.buffer = null;
            };
            _proto._addScopeLevel = function _addScopeLevel() {
              this._scopeClosers += "})";
            };
            _proto._closeScopeLevels = function _closeScopeLevels() {
              this._emitLine(this._scopeClosers + ";");
              this._scopeClosers = "";
            };
            _proto._withScopedSyntax = function _withScopedSyntax(func) {
              var _scopeClosers = this._scopeClosers;
              this._scopeClosers = "";
              func.call(this);
              this._closeScopeLevels();
              this._scopeClosers = _scopeClosers;
            };
            _proto._makeCallback = function _makeCallback(res) {
              var err = this._tmpid();
              return "function(" + err + (res ? "," + res : "") + ") {\nif(" + err + ") { cb(" + err + "); return; }";
            };
            _proto._tmpid = function _tmpid() {
              this.lastId++;
              return "t_" + this.lastId;
            };
            _proto._templateName = function _templateName() {
              return this.templateName == null ? "undefined" : JSON.stringify(this.templateName);
            };
            _proto._compileChildren = function _compileChildren(node, frame) {
              var _this2 = this;
              node.children.forEach(function(child) {
                _this2.compile(child, frame);
              });
            };
            _proto._compileAggregate = function _compileAggregate(node, frame, startChar, endChar) {
              var _this3 = this;
              if (startChar) {
                this._emit(startChar);
              }
              node.children.forEach(function(child, i) {
                if (i > 0) {
                  _this3._emit(",");
                }
                _this3.compile(child, frame);
              });
              if (endChar) {
                this._emit(endChar);
              }
            };
            _proto._compileExpression = function _compileExpression(node, frame) {
              this.assertType(node, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
              this.compile(node, frame);
            };
            _proto.assertType = function assertType(node) {
              for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                types[_key2 - 1] = arguments[_key2];
              }
              if (!types.some(function(t) {
                return node instanceof t;
              })) {
                this.fail("assertType: invalid type: " + node.typename, node.lineno, node.colno);
              }
            };
            _proto.compileCallExtension = function compileCallExtension(node, frame, async) {
              var _this4 = this;
              var args = node.args;
              var contentArgs = node.contentArgs;
              var autoescape = typeof node.autoescape === "boolean" ? node.autoescape : true;
              if (!async) {
                this._emit(this.buffer + " += runtime.suppressValue(");
              }
              this._emit('env.getExtension("' + node.extName + '")["' + node.prop + '"](');
              this._emit("context");
              if (args || contentArgs) {
                this._emit(",");
              }
              if (args) {
                if (!(args instanceof nodes.NodeList)) {
                  this.fail("compileCallExtension: arguments must be a NodeList, use `parser.parseSignature`");
                }
                args.children.forEach(function(arg, i) {
                  _this4._compileExpression(arg, frame);
                  if (i !== args.children.length - 1 || contentArgs.length) {
                    _this4._emit(",");
                  }
                });
              }
              if (contentArgs.length) {
                contentArgs.forEach(function(arg, i) {
                  if (i > 0) {
                    _this4._emit(",");
                  }
                  if (arg) {
                    _this4._emitLine("function(cb) {");
                    _this4._emitLine("if(!cb) { cb = function(err) { if(err) { throw err; }}}");
                    var id = _this4._pushBuffer();
                    _this4._withScopedSyntax(function() {
                      _this4.compile(arg, frame);
                      _this4._emitLine("cb(null, " + id + ");");
                    });
                    _this4._popBuffer();
                    _this4._emitLine("return " + id + ";");
                    _this4._emitLine("}");
                  } else {
                    _this4._emit("null");
                  }
                });
              }
              if (async) {
                var res = this._tmpid();
                this._emitLine(", " + this._makeCallback(res));
                this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");
                this._addScopeLevel();
              } else {
                this._emit(")");
                this._emit(", " + autoescape + " && env.opts.autoescape);\n");
              }
            };
            _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node, frame) {
              this.compileCallExtension(node, frame, true);
            };
            _proto.compileNodeList = function compileNodeList(node, frame) {
              this._compileChildren(node, frame);
            };
            _proto.compileLiteral = function compileLiteral(node) {
              if (typeof node.value === "string") {
                var val = node.value.replace(/\\/g, "\\\\");
                val = val.replace(/"/g, '\\"');
                val = val.replace(/\n/g, "\\n");
                val = val.replace(/\r/g, "\\r");
                val = val.replace(/\t/g, "\\t");
                val = val.replace(/\u2028/g, "\\u2028");
                this._emit('"' + val + '"');
              } else if (node.value === null) {
                this._emit("null");
              } else {
                this._emit(node.value.toString());
              }
            };
            _proto.compileSymbol = function compileSymbol(node, frame) {
              var name = node.value;
              var v = frame.lookup(name);
              if (v) {
                this._emit(v);
              } else {
                this._emit('runtime.contextOrFrameLookup(context, frame, "' + name + '")');
              }
            };
            _proto.compileGroup = function compileGroup(node, frame) {
              this._compileAggregate(node, frame, "(", ")");
            };
            _proto.compileArray = function compileArray(node, frame) {
              this._compileAggregate(node, frame, "[", "]");
            };
            _proto.compileDict = function compileDict(node, frame) {
              this._compileAggregate(node, frame, "{", "}");
            };
            _proto.compilePair = function compilePair(node, frame) {
              var key = node.key;
              var val = node.value;
              if (key instanceof nodes.Symbol) {
                key = new nodes.Literal(key.lineno, key.colno, key.value);
              } else if (!(key instanceof nodes.Literal && typeof key.value === "string")) {
                this.fail("compilePair: Dict keys must be strings or names", key.lineno, key.colno);
              }
              this.compile(key, frame);
              this._emit(": ");
              this._compileExpression(val, frame);
            };
            _proto.compileInlineIf = function compileInlineIf(node, frame) {
              this._emit("(");
              this.compile(node.cond, frame);
              this._emit("?");
              this.compile(node.body, frame);
              this._emit(":");
              if (node.else_ !== null) {
                this.compile(node.else_, frame);
              } else {
                this._emit('""');
              }
              this._emit(")");
            };
            _proto.compileIn = function compileIn(node, frame) {
              this._emit("runtime.inOperator(");
              this.compile(node.left, frame);
              this._emit(",");
              this.compile(node.right, frame);
              this._emit(")");
            };
            _proto.compileIs = function compileIs(node, frame) {
              var right = node.right.name ? node.right.name.value : node.right.value;
              this._emit('env.getTest("' + right + '").call(context, ');
              this.compile(node.left, frame);
              if (node.right.args) {
                this._emit(",");
                this.compile(node.right.args, frame);
              }
              this._emit(") === true");
            };
            _proto._binOpEmitter = function _binOpEmitter(node, frame, str) {
              this.compile(node.left, frame);
              this._emit(str);
              this.compile(node.right, frame);
            };
            _proto.compileOr = function compileOr(node, frame) {
              return this._binOpEmitter(node, frame, " || ");
            };
            _proto.compileAnd = function compileAnd(node, frame) {
              return this._binOpEmitter(node, frame, " && ");
            };
            _proto.compileAdd = function compileAdd(node, frame) {
              return this._binOpEmitter(node, frame, " + ");
            };
            _proto.compileConcat = function compileConcat(node, frame) {
              return this._binOpEmitter(node, frame, ' + "" + ');
            };
            _proto.compileSub = function compileSub(node, frame) {
              return this._binOpEmitter(node, frame, " - ");
            };
            _proto.compileMul = function compileMul(node, frame) {
              return this._binOpEmitter(node, frame, " * ");
            };
            _proto.compileDiv = function compileDiv(node, frame) {
              return this._binOpEmitter(node, frame, " / ");
            };
            _proto.compileMod = function compileMod(node, frame) {
              return this._binOpEmitter(node, frame, " % ");
            };
            _proto.compileNot = function compileNot(node, frame) {
              this._emit("!");
              this.compile(node.target, frame);
            };
            _proto.compileFloorDiv = function compileFloorDiv(node, frame) {
              this._emit("Math.floor(");
              this.compile(node.left, frame);
              this._emit(" / ");
              this.compile(node.right, frame);
              this._emit(")");
            };
            _proto.compilePow = function compilePow(node, frame) {
              this._emit("Math.pow(");
              this.compile(node.left, frame);
              this._emit(", ");
              this.compile(node.right, frame);
              this._emit(")");
            };
            _proto.compileNeg = function compileNeg(node, frame) {
              this._emit("-");
              this.compile(node.target, frame);
            };
            _proto.compilePos = function compilePos(node, frame) {
              this._emit("+");
              this.compile(node.target, frame);
            };
            _proto.compileCompare = function compileCompare(node, frame) {
              var _this5 = this;
              this.compile(node.expr, frame);
              node.ops.forEach(function(op) {
                _this5._emit(" " + compareOps[op.type] + " ");
                _this5.compile(op.expr, frame);
              });
            };
            _proto.compileLookupVal = function compileLookupVal(node, frame) {
              this._emit("runtime.memberLookup((");
              this._compileExpression(node.target, frame);
              this._emit("),");
              this._compileExpression(node.val, frame);
              this._emit(")");
            };
            _proto._getNodeName = function _getNodeName(node) {
              switch (node.typename) {
                case "Symbol":
                  return node.value;
                case "FunCall":
                  return "the return value of (" + this._getNodeName(node.name) + ")";
                case "LookupVal":
                  return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';
                case "Literal":
                  return node.value.toString();
                default:
                  return "--expression--";
              }
            };
            _proto.compileFunCall = function compileFunCall(node, frame) {
              this._emit("(lineno = " + node.lineno + ", colno = " + node.colno + ", ");
              this._emit("runtime.callWrap(");
              this._compileExpression(node.name, frame);
              this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');
              this._compileAggregate(node.args, frame, "[", "])");
              this._emit(")");
            };
            _proto.compileFilter = function compileFilter(node, frame) {
              var name = node.name;
              this.assertType(name, nodes.Symbol);
              this._emit('env.getFilter("' + name.value + '").call(context, ');
              this._compileAggregate(node.args, frame);
              this._emit(")");
            };
            _proto.compileFilterAsync = function compileFilterAsync(node, frame) {
              var name = node.name;
              var symbol = node.symbol.value;
              this.assertType(name, nodes.Symbol);
              frame.set(symbol, symbol);
              this._emit('env.getFilter("' + name.value + '").call(context, ');
              this._compileAggregate(node.args, frame);
              this._emitLine(", " + this._makeCallback(symbol));
              this._addScopeLevel();
            };
            _proto.compileKeywordArgs = function compileKeywordArgs(node, frame) {
              this._emit("runtime.makeKeywordArgs(");
              this.compileDict(node, frame);
              this._emit(")");
            };
            _proto.compileSet = function compileSet(node, frame) {
              var _this6 = this;
              var ids = [];
              node.targets.forEach(function(target) {
                var name = target.value;
                var id = frame.lookup(name);
                if (id === null || id === void 0) {
                  id = _this6._tmpid();
                  _this6._emitLine("var " + id + ";");
                }
                ids.push(id);
              });
              if (node.value) {
                this._emit(ids.join(" = ") + " = ");
                this._compileExpression(node.value, frame);
                this._emitLine(";");
              } else {
                this._emit(ids.join(" = ") + " = ");
                this.compile(node.body, frame);
                this._emitLine(";");
              }
              node.targets.forEach(function(target, i) {
                var id = ids[i];
                var name = target.value;
                _this6._emitLine('frame.set("' + name + '", ' + id + ", true);");
                _this6._emitLine("if(frame.topLevel) {");
                _this6._emitLine('context.setVariable("' + name + '", ' + id + ");");
                _this6._emitLine("}");
                if (name.charAt(0) !== "_") {
                  _this6._emitLine("if(frame.topLevel) {");
                  _this6._emitLine('context.addExport("' + name + '", ' + id + ");");
                  _this6._emitLine("}");
                }
              });
            };
            _proto.compileSwitch = function compileSwitch(node, frame) {
              var _this7 = this;
              this._emit("switch (");
              this.compile(node.expr, frame);
              this._emit(") {");
              node.cases.forEach(function(c, i) {
                _this7._emit("case ");
                _this7.compile(c.cond, frame);
                _this7._emit(": ");
                _this7.compile(c.body, frame);
                if (c.body.children.length) {
                  _this7._emitLine("break;");
                }
              });
              if (node.default) {
                this._emit("default:");
                this.compile(node.default, frame);
              }
              this._emit("}");
            };
            _proto.compileIf = function compileIf(node, frame, async) {
              var _this8 = this;
              this._emit("if(");
              this._compileExpression(node.cond, frame);
              this._emitLine(") {");
              this._withScopedSyntax(function() {
                _this8.compile(node.body, frame);
                if (async) {
                  _this8._emit("cb()");
                }
              });
              if (node.else_) {
                this._emitLine("}\nelse {");
                this._withScopedSyntax(function() {
                  _this8.compile(node.else_, frame);
                  if (async) {
                    _this8._emit("cb()");
                  }
                });
              } else if (async) {
                this._emitLine("}\nelse {");
                this._emit("cb()");
              }
              this._emitLine("}");
            };
            _proto.compileIfAsync = function compileIfAsync(node, frame) {
              this._emit("(function(cb) {");
              this.compileIf(node, frame, true);
              this._emit("})(" + this._makeCallback());
              this._addScopeLevel();
            };
            _proto._emitLoopBindings = function _emitLoopBindings(node, arr, i, len) {
              var _this9 = this;
              var bindings = [{
                name: "index",
                val: i + " + 1"
              }, {
                name: "index0",
                val: i
              }, {
                name: "revindex",
                val: len + " - " + i
              }, {
                name: "revindex0",
                val: len + " - " + i + " - 1"
              }, {
                name: "first",
                val: i + " === 0"
              }, {
                name: "last",
                val: i + " === " + len + " - 1"
              }, {
                name: "length",
                val: len
              }];
              bindings.forEach(function(b) {
                _this9._emitLine('frame.set("loop.' + b.name + '", ' + b.val + ");");
              });
            };
            _proto.compileFor = function compileFor(node, frame) {
              var _this10 = this;
              var i = this._tmpid();
              var len = this._tmpid();
              var arr = this._tmpid();
              frame = frame.push();
              this._emitLine("frame = frame.push();");
              this._emit("var " + arr + " = ");
              this._compileExpression(node.arr, frame);
              this._emitLine(";");
              this._emit("if(" + arr + ") {");
              this._emitLine(arr + " = runtime.fromIterator(" + arr + ");");
              if (node.name instanceof nodes.Array) {
                this._emitLine("var " + i + ";");
                this._emitLine("if(runtime.isArray(" + arr + ")) {");
                this._emitLine("var " + len + " = " + arr + ".length;");
                this._emitLine("for(" + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");
                node.name.children.forEach(function(child, u) {
                  var tid = _this10._tmpid();
                  _this10._emitLine("var " + tid + " = " + arr + "[" + i + "][" + u + "];");
                  _this10._emitLine('frame.set("' + child + '", ' + arr + "[" + i + "][" + u + "]);");
                  frame.set(node.name.children[u].value, tid);
                });
                this._emitLoopBindings(node, arr, i, len);
                this._withScopedSyntax(function() {
                  _this10.compile(node.body, frame);
                });
                this._emitLine("}");
                this._emitLine("} else {");
                var _node$name$children = node.name.children, key = _node$name$children[0], val = _node$name$children[1];
                var k = this._tmpid();
                var v = this._tmpid();
                frame.set(key.value, k);
                frame.set(val.value, v);
                this._emitLine(i + " = -1;");
                this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");
                this._emitLine("for(var " + k + " in " + arr + ") {");
                this._emitLine(i + "++;");
                this._emitLine("var " + v + " = " + arr + "[" + k + "];");
                this._emitLine('frame.set("' + key.value + '", ' + k + ");");
                this._emitLine('frame.set("' + val.value + '", ' + v + ");");
                this._emitLoopBindings(node, arr, i, len);
                this._withScopedSyntax(function() {
                  _this10.compile(node.body, frame);
                });
                this._emitLine("}");
                this._emitLine("}");
              } else {
                var _v = this._tmpid();
                frame.set(node.name.value, _v);
                this._emitLine("var " + len + " = " + arr + ".length;");
                this._emitLine("for(var " + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");
                this._emitLine("var " + _v + " = " + arr + "[" + i + "];");
                this._emitLine('frame.set("' + node.name.value + '", ' + _v + ");");
                this._emitLoopBindings(node, arr, i, len);
                this._withScopedSyntax(function() {
                  _this10.compile(node.body, frame);
                });
                this._emitLine("}");
              }
              this._emitLine("}");
              if (node.else_) {
                this._emitLine("if (!" + len + ") {");
                this.compile(node.else_, frame);
                this._emitLine("}");
              }
              this._emitLine("frame = frame.pop();");
            };
            _proto._compileAsyncLoop = function _compileAsyncLoop(node, frame, parallel) {
              var _this11 = this;
              var i = this._tmpid();
              var len = this._tmpid();
              var arr = this._tmpid();
              var asyncMethod = parallel ? "asyncAll" : "asyncEach";
              frame = frame.push();
              this._emitLine("frame = frame.push();");
              this._emit("var " + arr + " = runtime.fromIterator(");
              this._compileExpression(node.arr, frame);
              this._emitLine(");");
              if (node.name instanceof nodes.Array) {
                var arrayLen = node.name.children.length;
                this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");
                node.name.children.forEach(function(name) {
                  _this11._emit(name.value + ",");
                });
                this._emit(i + "," + len + ",next) {");
                node.name.children.forEach(function(name) {
                  var id2 = name.value;
                  frame.set(id2, id2);
                  _this11._emitLine('frame.set("' + id2 + '", ' + id2 + ");");
                });
              } else {
                var id = node.name.value;
                this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i + ", " + len + ",next) {");
                this._emitLine('frame.set("' + id + '", ' + id + ");");
                frame.set(id, id);
              }
              this._emitLoopBindings(node, arr, i, len);
              this._withScopedSyntax(function() {
                var buf;
                if (parallel) {
                  buf = _this11._pushBuffer();
                }
                _this11.compile(node.body, frame);
                _this11._emitLine("next(" + i + (buf ? "," + buf : "") + ");");
                if (parallel) {
                  _this11._popBuffer();
                }
              });
              var output = this._tmpid();
              this._emitLine("}, " + this._makeCallback(output));
              this._addScopeLevel();
              if (parallel) {
                this._emitLine(this.buffer + " += " + output + ";");
              }
              if (node.else_) {
                this._emitLine("if (!" + arr + ".length) {");
                this.compile(node.else_, frame);
                this._emitLine("}");
              }
              this._emitLine("frame = frame.pop();");
            };
            _proto.compileAsyncEach = function compileAsyncEach(node, frame) {
              this._compileAsyncLoop(node, frame);
            };
            _proto.compileAsyncAll = function compileAsyncAll(node, frame) {
              this._compileAsyncLoop(node, frame, true);
            };
            _proto._compileMacro = function _compileMacro(node, frame) {
              var _this12 = this;
              var args = [];
              var kwargs = null;
              var funcId = "macro_" + this._tmpid();
              var keepFrame = frame !== void 0;
              node.args.children.forEach(function(arg, i) {
                if (i === node.args.children.length - 1 && arg instanceof nodes.Dict) {
                  kwargs = arg;
                } else {
                  _this12.assertType(arg, nodes.Symbol);
                  args.push(arg);
                }
              });
              var realNames = [].concat(args.map(function(n) {
                return "l_" + n.value;
              }), ["kwargs"]);
              var argNames = args.map(function(n) {
                return '"' + n.value + '"';
              });
              var kwargNames = (kwargs && kwargs.children || []).map(function(n) {
                return '"' + n.key.value + '"';
              });
              var currFrame;
              if (keepFrame) {
                currFrame = frame.push(true);
              } else {
                currFrame = new Frame();
              }
              this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(", ") + "], ", "[" + kwargNames.join(", ") + "], ", "function (" + realNames.join(", ") + ") {", "var callerFrame = frame;", "frame = " + (keepFrame ? "frame.push(true);" : "new runtime.Frame();"), "kwargs = kwargs || {};", 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }');
              args.forEach(function(arg) {
                _this12._emitLine('frame.set("' + arg.value + '", l_' + arg.value + ");");
                currFrame.set(arg.value, "l_" + arg.value);
              });
              if (kwargs) {
                kwargs.children.forEach(function(pair) {
                  var name = pair.key.value;
                  _this12._emit('frame.set("' + name + '", ');
                  _this12._emit('Object.prototype.hasOwnProperty.call(kwargs, "' + name + '")');
                  _this12._emit(' ? kwargs["' + name + '"] : ');
                  _this12._compileExpression(pair.value, currFrame);
                  _this12._emit(");");
                });
              }
              var bufferId = this._pushBuffer();
              this._withScopedSyntax(function() {
                _this12.compile(node.body, currFrame);
              });
              this._emitLine("frame = " + (keepFrame ? "frame.pop();" : "callerFrame;"));
              this._emitLine("return new runtime.SafeString(" + bufferId + ");");
              this._emitLine("});");
              this._popBuffer();
              return funcId;
            };
            _proto.compileMacro = function compileMacro(node, frame) {
              var funcId = this._compileMacro(node);
              var name = node.name.value;
              frame.set(name, funcId);
              if (frame.parent) {
                this._emitLine('frame.set("' + name + '", ' + funcId + ");");
              } else {
                if (node.name.value.charAt(0) !== "_") {
                  this._emitLine('context.addExport("' + name + '");');
                }
                this._emitLine('context.setVariable("' + name + '", ' + funcId + ");");
              }
            };
            _proto.compileCaller = function compileCaller(node, frame) {
              this._emit("(function (){");
              var funcId = this._compileMacro(node, frame);
              this._emit("return " + funcId + ";})()");
            };
            _proto._compileGetTemplate = function _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
              var parentTemplateId = this._tmpid();
              var parentName = this._templateName();
              var cb = this._makeCallback(parentTemplateId);
              var eagerCompileArg = eagerCompile ? "true" : "false";
              var ignoreMissingArg = ignoreMissing ? "true" : "false";
              this._emit("env.getTemplate(");
              this._compileExpression(node.template, frame);
              this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);
              return parentTemplateId;
            };
            _proto.compileImport = function compileImport(node, frame) {
              var target = node.target.value;
              var id = this._compileGetTemplate(node, frame, false, false);
              this._addScopeLevel();
              this._emitLine(id + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(id));
              this._addScopeLevel();
              frame.set(target, id);
              if (frame.parent) {
                this._emitLine('frame.set("' + target + '", ' + id + ");");
              } else {
                this._emitLine('context.setVariable("' + target + '", ' + id + ");");
              }
            };
            _proto.compileFromImport = function compileFromImport(node, frame) {
              var _this13 = this;
              var importedId = this._compileGetTemplate(node, frame, false, false);
              this._addScopeLevel();
              this._emitLine(importedId + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(importedId));
              this._addScopeLevel();
              node.names.children.forEach(function(nameNode) {
                var name;
                var alias;
                var id = _this13._tmpid();
                if (nameNode instanceof nodes.Pair) {
                  name = nameNode.key.value;
                  alias = nameNode.value.value;
                } else {
                  name = nameNode.value;
                  alias = name;
                }
                _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ', "' + name + '")) {');
                _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");
                _this13._emitLine("} else {");
                _this13._emitLine(`cb(new Error("cannot import '` + name + `'")); return;`);
                _this13._emitLine("}");
                frame.set(alias, id);
                if (frame.parent) {
                  _this13._emitLine('frame.set("' + alias + '", ' + id + ");");
                } else {
                  _this13._emitLine('context.setVariable("' + alias + '", ' + id + ");");
                }
              });
            };
            _proto.compileBlock = function compileBlock(node) {
              var id = this._tmpid();
              if (!this.inBlock) {
                this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
              }
              this._emit('context.getBlock("' + node.name.value + '")');
              if (!this.inBlock) {
                this._emit(")");
              }
              this._emitLine("(env, context, frame, runtime, " + this._makeCallback(id));
              this._emitLine(this.buffer + " += " + id + ";");
              this._addScopeLevel();
            };
            _proto.compileSuper = function compileSuper(node, frame) {
              var name = node.blockName.value;
              var id = node.symbol.value;
              var cb = this._makeCallback(id);
              this._emitLine('context.getSuper(env, "' + name + '", b_' + name + ", frame, runtime, " + cb);
              this._emitLine(id + " = runtime.markSafe(" + id + ");");
              this._addScopeLevel();
              frame.set(id, id);
            };
            _proto.compileExtends = function compileExtends(node, frame) {
              var k = this._tmpid();
              var parentTemplateId = this._compileGetTemplate(node, frame, true, false);
              this._emitLine("parentTemplate = " + parentTemplateId);
              this._emitLine("for(var " + k + " in parentTemplate.blocks) {");
              this._emitLine("context.addBlock(" + k + ", parentTemplate.blocks[" + k + "]);");
              this._emitLine("}");
              this._addScopeLevel();
            };
            _proto.compileInclude = function compileInclude(node, frame) {
              this._emitLine("var tasks = [];");
              this._emitLine("tasks.push(");
              this._emitLine("function(callback) {");
              var id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);
              this._emitLine("callback(null," + id + ");});");
              this._emitLine("});");
              var id2 = this._tmpid();
              this._emitLine("tasks.push(");
              this._emitLine("function(template, callback){");
              this._emitLine("template.render(context.getVariables(), frame, " + this._makeCallback(id2));
              this._emitLine("callback(null," + id2 + ");});");
              this._emitLine("});");
              this._emitLine("tasks.push(");
              this._emitLine("function(result, callback){");
              this._emitLine(this.buffer + " += result;");
              this._emitLine("callback(null);");
              this._emitLine("});");
              this._emitLine("env.waterfall(tasks, function(){");
              this._addScopeLevel();
            };
            _proto.compileTemplateData = function compileTemplateData(node, frame) {
              this.compileLiteral(node, frame);
            };
            _proto.compileCapture = function compileCapture(node, frame) {
              var _this14 = this;
              var buffer = this.buffer;
              this.buffer = "output";
              this._emitLine("(function() {");
              this._emitLine('var output = "";');
              this._withScopedSyntax(function() {
                _this14.compile(node.body, frame);
              });
              this._emitLine("return output;");
              this._emitLine("})()");
              this.buffer = buffer;
            };
            _proto.compileOutput = function compileOutput(node, frame) {
              var _this15 = this;
              var children2 = node.children;
              children2.forEach(function(child) {
                if (child instanceof nodes.TemplateData) {
                  if (child.value) {
                    _this15._emit(_this15.buffer + " += ");
                    _this15.compileLiteral(child, frame);
                    _this15._emitLine(";");
                  }
                } else {
                  _this15._emit(_this15.buffer + " += runtime.suppressValue(");
                  if (_this15.throwOnUndefined) {
                    _this15._emit("runtime.ensureDefined(");
                  }
                  _this15.compile(child, frame);
                  if (_this15.throwOnUndefined) {
                    _this15._emit("," + node.lineno + "," + node.colno + ")");
                  }
                  _this15._emit(", env.opts.autoescape);\n");
                }
              });
            };
            _proto.compileRoot = function compileRoot(node, frame) {
              var _this16 = this;
              if (frame) {
                this.fail("compileRoot: root node can't have frame");
              }
              frame = new Frame();
              this._emitFuncBegin(node, "root");
              this._emitLine("var parentTemplate = null;");
              this._compileChildren(node, frame);
              this._emitLine("if(parentTemplate) {");
              this._emitLine("parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);");
              this._emitLine("} else {");
              this._emitLine("cb(null, " + this.buffer + ");");
              this._emitLine("}");
              this._emitFuncEnd(true);
              this.inBlock = true;
              var blockNames = [];
              var blocks = node.findAll(nodes.Block);
              blocks.forEach(function(block, i) {
                var name = block.name.value;
                if (blockNames.indexOf(name) !== -1) {
                  throw new Error('Block "' + name + '" defined more than once.');
                }
                blockNames.push(name);
                _this16._emitFuncBegin(block, "b_" + name);
                var tmpFrame = new Frame();
                _this16._emitLine("var frame = frame.push(true);");
                _this16.compile(block.body, tmpFrame);
                _this16._emitFuncEnd();
              });
              this._emitLine("return {");
              blocks.forEach(function(block, i) {
                var blockName = "b_" + block.name.value;
                _this16._emitLine(blockName + ": " + blockName + ",");
              });
              this._emitLine("root: root\n};");
            };
            _proto.compile = function compile(node, frame) {
              var _compile = this["compile" + node.typename];
              if (_compile) {
                _compile.call(this, node, frame);
              } else {
                this.fail("compile: Cannot compile node: " + node.typename, node.lineno, node.colno);
              }
            };
            _proto.getCode = function getCode() {
              return this.codebuf.join("");
            };
            return Compiler2;
          }(Obj);
          module3.exports = {
            compile: function compile(src, asyncFilters, extensions, name, opts) {
              if (opts === void 0) {
                opts = {};
              }
              var c = new Compiler(name, opts.throwOnUndefined);
              var preprocessors = (extensions || []).map(function(ext) {
                return ext.preprocess;
              }).filter(function(f) {
                return !!f;
              });
              var processedSrc = preprocessors.reduce(function(s, processor) {
                return processor(s);
              }, src);
              c.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
              return c.getCode();
            },
            Compiler
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          var path = __webpack_require__(4);
          var _require = __webpack_require__(1), EmitterObj = _require.EmitterObj;
          module3.exports = /* @__PURE__ */ function(_EmitterObj) {
            _inheritsLoose(Loader, _EmitterObj);
            function Loader() {
              return _EmitterObj.apply(this, arguments) || this;
            }
            var _proto = Loader.prototype;
            _proto.resolve = function resolve(from, to) {
              return path.resolve(path.dirname(from), to);
            };
            _proto.isRelative = function isRelative(filename) {
              return filename.indexOf("./") === 0 || filename.indexOf("../") === 0;
            };
            return Loader;
          }(EmitterObj);
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          var asap = __webpack_require__(12);
          var _waterfall = __webpack_require__(15);
          var lib = __webpack_require__(0);
          var compiler = __webpack_require__(5);
          var filters = __webpack_require__(18);
          var _require = __webpack_require__(10), FileSystemLoader = _require.FileSystemLoader, WebLoader = _require.WebLoader, PrecompiledLoader = _require.PrecompiledLoader;
          var tests = __webpack_require__(20);
          var globals2 = __webpack_require__(21);
          var _require2 = __webpack_require__(1), Obj = _require2.Obj, EmitterObj = _require2.EmitterObj;
          var globalRuntime = __webpack_require__(2);
          var handleError = globalRuntime.handleError, Frame = globalRuntime.Frame;
          var expressApp = __webpack_require__(22);
          function callbackAsap(cb, err, res) {
            asap(function() {
              cb(err, res);
            });
          }
          var noopTmplSrc = {
            type: "code",
            obj: {
              root: function root(env, context, frame, runtime, cb) {
                try {
                  cb(null, "");
                } catch (e) {
                  cb(handleError(e, null, null));
                }
              }
            }
          };
          var Environment = /* @__PURE__ */ function(_EmitterObj) {
            _inheritsLoose(Environment2, _EmitterObj);
            function Environment2() {
              return _EmitterObj.apply(this, arguments) || this;
            }
            var _proto = Environment2.prototype;
            _proto.init = function init2(loaders, opts) {
              var _this = this;
              opts = this.opts = opts || {};
              this.opts.dev = !!opts.dev;
              this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;
              this.opts.throwOnUndefined = !!opts.throwOnUndefined;
              this.opts.trimBlocks = !!opts.trimBlocks;
              this.opts.lstripBlocks = !!opts.lstripBlocks;
              this.loaders = [];
              if (!loaders) {
                if (FileSystemLoader) {
                  this.loaders = [new FileSystemLoader("views")];
                } else if (WebLoader) {
                  this.loaders = [new WebLoader("/views")];
                }
              } else {
                this.loaders = lib.isArray(loaders) ? loaders : [loaders];
              }
              if (typeof window !== "undefined" && window.nunjucksPrecompiled) {
                this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
              }
              this._initLoaders();
              this.globals = globals2();
              this.filters = {};
              this.tests = {};
              this.asyncFilters = [];
              this.extensions = {};
              this.extensionsList = [];
              lib._entries(filters).forEach(function(_ref) {
                var name = _ref[0], filter = _ref[1];
                return _this.addFilter(name, filter);
              });
              lib._entries(tests).forEach(function(_ref2) {
                var name = _ref2[0], test = _ref2[1];
                return _this.addTest(name, test);
              });
            };
            _proto._initLoaders = function _initLoaders() {
              var _this2 = this;
              this.loaders.forEach(function(loader) {
                loader.cache = {};
                if (typeof loader.on === "function") {
                  loader.on("update", function(name, fullname) {
                    loader.cache[name] = null;
                    _this2.emit("update", name, fullname, loader);
                  });
                  loader.on("load", function(name, source) {
                    _this2.emit("load", name, source, loader);
                  });
                }
              });
            };
            _proto.invalidateCache = function invalidateCache() {
              this.loaders.forEach(function(loader) {
                loader.cache = {};
              });
            };
            _proto.addExtension = function addExtension(name, extension) {
              extension.__name = name;
              this.extensions[name] = extension;
              this.extensionsList.push(extension);
              return this;
            };
            _proto.removeExtension = function removeExtension(name) {
              var extension = this.getExtension(name);
              if (!extension) {
                return;
              }
              this.extensionsList = lib.without(this.extensionsList, extension);
              delete this.extensions[name];
            };
            _proto.getExtension = function getExtension(name) {
              return this.extensions[name];
            };
            _proto.hasExtension = function hasExtension(name) {
              return !!this.extensions[name];
            };
            _proto.addGlobal = function addGlobal(name, value) {
              this.globals[name] = value;
              return this;
            };
            _proto.getGlobal = function getGlobal(name) {
              if (typeof this.globals[name] === "undefined") {
                throw new Error("global not found: " + name);
              }
              return this.globals[name];
            };
            _proto.addFilter = function addFilter(name, func, async) {
              var wrapped = func;
              if (async) {
                this.asyncFilters.push(name);
              }
              this.filters[name] = wrapped;
              return this;
            };
            _proto.getFilter = function getFilter(name) {
              if (!this.filters[name]) {
                throw new Error("filter not found: " + name);
              }
              return this.filters[name];
            };
            _proto.addTest = function addTest(name, func) {
              this.tests[name] = func;
              return this;
            };
            _proto.getTest = function getTest(name) {
              if (!this.tests[name]) {
                throw new Error("test not found: " + name);
              }
              return this.tests[name];
            };
            _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
              var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
              return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
            };
            _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
              var _this3 = this;
              var that = this;
              var tmpl = null;
              if (name && name.raw) {
                name = name.raw;
              }
              if (lib.isFunction(parentName)) {
                cb = parentName;
                parentName = null;
                eagerCompile = eagerCompile || false;
              }
              if (lib.isFunction(eagerCompile)) {
                cb = eagerCompile;
                eagerCompile = false;
              }
              if (name instanceof Template) {
                tmpl = name;
              } else if (typeof name !== "string") {
                throw new Error("template names must be a string: " + name);
              } else {
                for (var i = 0; i < this.loaders.length; i++) {
                  var loader = this.loaders[i];
                  tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];
                  if (tmpl) {
                    break;
                  }
                }
              }
              if (tmpl) {
                if (eagerCompile) {
                  tmpl.compile();
                }
                if (cb) {
                  cb(null, tmpl);
                  return void 0;
                } else {
                  return tmpl;
                }
              }
              var syncResult;
              var createTemplate = function createTemplate2(err, info) {
                if (!info && !err && !ignoreMissing) {
                  err = new Error("template not found: " + name);
                }
                if (err) {
                  if (cb) {
                    cb(err);
                    return;
                  } else {
                    throw err;
                  }
                }
                var newTmpl;
                if (!info) {
                  newTmpl = new Template(noopTmplSrc, _this3, "", eagerCompile);
                } else {
                  newTmpl = new Template(info.src, _this3, info.path, eagerCompile);
                  if (!info.noCache) {
                    info.loader.cache[name] = newTmpl;
                  }
                }
                if (cb) {
                  cb(null, newTmpl);
                } else {
                  syncResult = newTmpl;
                }
              };
              lib.asyncIter(this.loaders, function(loader2, i2, next, done) {
                function handle(err, src) {
                  if (err) {
                    done(err);
                  } else if (src) {
                    src.loader = loader2;
                    done(null, src);
                  } else {
                    next();
                  }
                }
                name = that.resolveTemplate(loader2, parentName, name);
                if (loader2.async) {
                  loader2.getSource(name, handle);
                } else {
                  handle(null, loader2.getSource(name));
                }
              }, createTemplate);
              return syncResult;
            };
            _proto.express = function express(app2) {
              return expressApp(this, app2);
            };
            _proto.render = function render(name, ctx, cb) {
              if (lib.isFunction(ctx)) {
                cb = ctx;
                ctx = null;
              }
              var syncResult = null;
              this.getTemplate(name, function(err, tmpl) {
                if (err && cb) {
                  callbackAsap(cb, err);
                } else if (err) {
                  throw err;
                } else {
                  syncResult = tmpl.render(ctx, cb);
                }
              });
              return syncResult;
            };
            _proto.renderString = function renderString(src, ctx, opts, cb) {
              if (lib.isFunction(opts)) {
                cb = opts;
                opts = {};
              }
              opts = opts || {};
              var tmpl = new Template(src, this, opts.path);
              return tmpl.render(ctx, cb);
            };
            _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
              return _waterfall(tasks, callback, forceAsync);
            };
            return Environment2;
          }(EmitterObj);
          var Context = /* @__PURE__ */ function(_Obj) {
            _inheritsLoose(Context2, _Obj);
            function Context2() {
              return _Obj.apply(this, arguments) || this;
            }
            var _proto2 = Context2.prototype;
            _proto2.init = function init2(ctx, blocks, env) {
              var _this4 = this;
              this.env = env || new Environment();
              this.ctx = lib.extend({}, ctx);
              this.blocks = {};
              this.exported = [];
              lib.keys(blocks).forEach(function(name) {
                _this4.addBlock(name, blocks[name]);
              });
            };
            _proto2.lookup = function lookup(name) {
              if (name in this.env.globals && !(name in this.ctx)) {
                return this.env.globals[name];
              } else {
                return this.ctx[name];
              }
            };
            _proto2.setVariable = function setVariable(name, val) {
              this.ctx[name] = val;
            };
            _proto2.getVariables = function getVariables() {
              return this.ctx;
            };
            _proto2.addBlock = function addBlock(name, block) {
              this.blocks[name] = this.blocks[name] || [];
              this.blocks[name].push(block);
              return this;
            };
            _proto2.getBlock = function getBlock(name) {
              if (!this.blocks[name]) {
                throw new Error('unknown block "' + name + '"');
              }
              return this.blocks[name][0];
            };
            _proto2.getSuper = function getSuper(env, name, block, frame, runtime, cb) {
              var idx = lib.indexOf(this.blocks[name] || [], block);
              var blk = this.blocks[name][idx + 1];
              var context = this;
              if (idx === -1 || !blk) {
                throw new Error('no super block available for "' + name + '"');
              }
              blk(env, context, frame, runtime, cb);
            };
            _proto2.addExport = function addExport(name) {
              this.exported.push(name);
            };
            _proto2.getExported = function getExported() {
              var _this5 = this;
              var exported = {};
              this.exported.forEach(function(name) {
                exported[name] = _this5.ctx[name];
              });
              return exported;
            };
            return Context2;
          }(Obj);
          var Template = /* @__PURE__ */ function(_Obj2) {
            _inheritsLoose(Template2, _Obj2);
            function Template2() {
              return _Obj2.apply(this, arguments) || this;
            }
            var _proto3 = Template2.prototype;
            _proto3.init = function init2(src, env, path, eagerCompile) {
              this.env = env || new Environment();
              if (lib.isObject(src)) {
                switch (src.type) {
                  case "code":
                    this.tmplProps = src.obj;
                    break;
                  case "string":
                    this.tmplStr = src.obj;
                    break;
                  default:
                    throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
                }
              } else if (lib.isString(src)) {
                this.tmplStr = src;
              } else {
                throw new Error("src must be a string or an object describing the source");
              }
              this.path = path;
              if (eagerCompile) {
                try {
                  this._compile();
                } catch (err) {
                  throw lib._prettifyError(this.path, this.env.opts.dev, err);
                }
              } else {
                this.compiled = false;
              }
            };
            _proto3.render = function render(ctx, parentFrame, cb) {
              var _this6 = this;
              if (typeof ctx === "function") {
                cb = ctx;
                ctx = {};
              } else if (typeof parentFrame === "function") {
                cb = parentFrame;
                parentFrame = null;
              }
              var forceAsync = !parentFrame;
              try {
                this.compile();
              } catch (e) {
                var err = lib._prettifyError(this.path, this.env.opts.dev, e);
                if (cb) {
                  return callbackAsap(cb, err);
                } else {
                  throw err;
                }
              }
              var context = new Context(ctx || {}, this.blocks, this.env);
              var frame = parentFrame ? parentFrame.push(true) : new Frame();
              frame.topLevel = true;
              var syncResult = null;
              var didError = false;
              this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err2, res) {
                if (didError && cb && typeof res !== "undefined") {
                  return;
                }
                if (err2) {
                  err2 = lib._prettifyError(_this6.path, _this6.env.opts.dev, err2);
                  didError = true;
                }
                if (cb) {
                  if (forceAsync) {
                    callbackAsap(cb, err2, res);
                  } else {
                    cb(err2, res);
                  }
                } else {
                  if (err2) {
                    throw err2;
                  }
                  syncResult = res;
                }
              });
              return syncResult;
            };
            _proto3.getExported = function getExported(ctx, parentFrame, cb) {
              if (typeof ctx === "function") {
                cb = ctx;
                ctx = {};
              }
              if (typeof parentFrame === "function") {
                cb = parentFrame;
                parentFrame = null;
              }
              try {
                this.compile();
              } catch (e) {
                if (cb) {
                  return cb(e);
                } else {
                  throw e;
                }
              }
              var frame = parentFrame ? parentFrame.push() : new Frame();
              frame.topLevel = true;
              var context = new Context(ctx || {}, this.blocks, this.env);
              this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err) {
                if (err) {
                  cb(err, null);
                } else {
                  cb(null, context.getExported());
                }
              });
            };
            _proto3.compile = function compile() {
              if (!this.compiled) {
                this._compile();
              }
            };
            _proto3._compile = function _compile() {
              var props;
              if (this.tmplProps) {
                props = this.tmplProps;
              } else {
                var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
                var func = new Function(source);
                props = func();
              }
              this.blocks = this._getBlocks(props);
              this.rootRenderFunc = props.root;
              this.compiled = true;
            };
            _proto3._getBlocks = function _getBlocks(props) {
              var blocks = {};
              lib.keys(props).forEach(function(k) {
                if (k.slice(0, 2) === "b_") {
                  blocks[k.slice(2)] = props[k];
                }
              });
              return blocks;
            };
            return Template2;
          }(Obj);
          module3.exports = {
            Environment,
            Template
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          var lexer = __webpack_require__(9);
          var nodes = __webpack_require__(3);
          var Obj = __webpack_require__(1).Obj;
          var lib = __webpack_require__(0);
          var Parser = /* @__PURE__ */ function(_Obj) {
            _inheritsLoose(Parser2, _Obj);
            function Parser2() {
              return _Obj.apply(this, arguments) || this;
            }
            var _proto = Parser2.prototype;
            _proto.init = function init2(tokens) {
              this.tokens = tokens;
              this.peeked = null;
              this.breakOnBlocks = null;
              this.dropLeadingWhitespace = false;
              this.extensions = [];
            };
            _proto.nextToken = function nextToken(withWhitespace) {
              var tok;
              if (this.peeked) {
                if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
                  this.peeked = null;
                } else {
                  tok = this.peeked;
                  this.peeked = null;
                  return tok;
                }
              }
              tok = this.tokens.nextToken();
              if (!withWhitespace) {
                while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
                  tok = this.tokens.nextToken();
                }
              }
              return tok;
            };
            _proto.peekToken = function peekToken() {
              this.peeked = this.peeked || this.nextToken();
              return this.peeked;
            };
            _proto.pushToken = function pushToken(tok) {
              if (this.peeked) {
                throw new Error("pushToken: can only push one token on between reads");
              }
              this.peeked = tok;
            };
            _proto.error = function error(msg, lineno, colno) {
              if (lineno === void 0 || colno === void 0) {
                var tok = this.peekToken() || {};
                lineno = tok.lineno;
                colno = tok.colno;
              }
              if (lineno !== void 0) {
                lineno += 1;
              }
              if (colno !== void 0) {
                colno += 1;
              }
              return new lib.TemplateError(msg, lineno, colno);
            };
            _proto.fail = function fail(msg, lineno, colno) {
              throw this.error(msg, lineno, colno);
            };
            _proto.skip = function skip(type) {
              var tok = this.nextToken();
              if (!tok || tok.type !== type) {
                this.pushToken(tok);
                return false;
              }
              return true;
            };
            _proto.expect = function expect(type) {
              var tok = this.nextToken();
              if (tok.type !== type) {
                this.fail("expected " + type + ", got " + tok.type, tok.lineno, tok.colno);
              }
              return tok;
            };
            _proto.skipValue = function skipValue(type, val) {
              var tok = this.nextToken();
              if (!tok || tok.type !== type || tok.value !== val) {
                this.pushToken(tok);
                return false;
              }
              return true;
            };
            _proto.skipSymbol = function skipSymbol(val) {
              return this.skipValue(lexer.TOKEN_SYMBOL, val);
            };
            _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
              var tok;
              if (!name) {
                tok = this.peekToken();
                if (!tok) {
                  this.fail("unexpected end of file");
                }
                if (tok.type !== lexer.TOKEN_SYMBOL) {
                  this.fail("advanceAfterBlockEnd: expected symbol token or explicit name to be passed");
                }
                name = this.nextToken().value;
              }
              tok = this.nextToken();
              if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
                if (tok.value.charAt(0) === "-") {
                  this.dropLeadingWhitespace = true;
                }
              } else {
                this.fail("expected block end in " + name + " statement");
              }
              return tok;
            };
            _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
              var tok = this.nextToken();
              if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
                this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === "-";
              } else {
                this.pushToken(tok);
                this.fail("expected variable end");
              }
            };
            _proto.parseFor = function parseFor() {
              var forTok = this.peekToken();
              var node;
              var endBlock;
              if (this.skipSymbol("for")) {
                node = new nodes.For(forTok.lineno, forTok.colno);
                endBlock = "endfor";
              } else if (this.skipSymbol("asyncEach")) {
                node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
                endBlock = "endeach";
              } else if (this.skipSymbol("asyncAll")) {
                node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
                endBlock = "endall";
              } else {
                this.fail("parseFor: expected for{Async}", forTok.lineno, forTok.colno);
              }
              node.name = this.parsePrimary();
              if (!(node.name instanceof nodes.Symbol)) {
                this.fail("parseFor: variable name expected for loop");
              }
              var type = this.peekToken().type;
              if (type === lexer.TOKEN_COMMA) {
                var key = node.name;
                node.name = new nodes.Array(key.lineno, key.colno);
                node.name.addChild(key);
                while (this.skip(lexer.TOKEN_COMMA)) {
                  var prim = this.parsePrimary();
                  node.name.addChild(prim);
                }
              }
              if (!this.skipSymbol("in")) {
                this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
              }
              node.arr = this.parseExpression();
              this.advanceAfterBlockEnd(forTok.value);
              node.body = this.parseUntilBlocks(endBlock, "else");
              if (this.skipSymbol("else")) {
                this.advanceAfterBlockEnd("else");
                node.else_ = this.parseUntilBlocks(endBlock);
              }
              this.advanceAfterBlockEnd();
              return node;
            };
            _proto.parseMacro = function parseMacro() {
              var macroTok = this.peekToken();
              if (!this.skipSymbol("macro")) {
                this.fail("expected macro");
              }
              var name = this.parsePrimary(true);
              var args = this.parseSignature();
              var node = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
              this.advanceAfterBlockEnd(macroTok.value);
              node.body = this.parseUntilBlocks("endmacro");
              this.advanceAfterBlockEnd();
              return node;
            };
            _proto.parseCall = function parseCall() {
              var callTok = this.peekToken();
              if (!this.skipSymbol("call")) {
                this.fail("expected call");
              }
              var callerArgs = this.parseSignature(true) || new nodes.NodeList();
              var macroCall = this.parsePrimary();
              this.advanceAfterBlockEnd(callTok.value);
              var body = this.parseUntilBlocks("endcall");
              this.advanceAfterBlockEnd();
              var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, "caller");
              var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body);
              var args = macroCall.args.children;
              if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
                args.push(new nodes.KeywordArgs());
              }
              var kwargs = args[args.length - 1];
              kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
              return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
            };
            _proto.parseWithContext = function parseWithContext() {
              var tok = this.peekToken();
              var withContext = null;
              if (this.skipSymbol("with")) {
                withContext = true;
              } else if (this.skipSymbol("without")) {
                withContext = false;
              }
              if (withContext !== null) {
                if (!this.skipSymbol("context")) {
                  this.fail("parseFrom: expected context after with/without", tok.lineno, tok.colno);
                }
              }
              return withContext;
            };
            _proto.parseImport = function parseImport() {
              var importTok = this.peekToken();
              if (!this.skipSymbol("import")) {
                this.fail("parseImport: expected import", importTok.lineno, importTok.colno);
              }
              var template = this.parseExpression();
              if (!this.skipSymbol("as")) {
                this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
              }
              var target = this.parseExpression();
              var withContext = this.parseWithContext();
              var node = new nodes.Import(importTok.lineno, importTok.colno, template, target, withContext);
              this.advanceAfterBlockEnd(importTok.value);
              return node;
            };
            _proto.parseFrom = function parseFrom() {
              var fromTok = this.peekToken();
              if (!this.skipSymbol("from")) {
                this.fail("parseFrom: expected from");
              }
              var template = this.parseExpression();
              if (!this.skipSymbol("import")) {
                this.fail("parseFrom: expected import", fromTok.lineno, fromTok.colno);
              }
              var names = new nodes.NodeList();
              var withContext;
              while (1) {
                var nextTok = this.peekToken();
                if (nextTok.type === lexer.TOKEN_BLOCK_END) {
                  if (!names.children.length) {
                    this.fail("parseFrom: Expected at least one import name", fromTok.lineno, fromTok.colno);
                  }
                  if (nextTok.value.charAt(0) === "-") {
                    this.dropLeadingWhitespace = true;
                  }
                  this.nextToken();
                  break;
                }
                if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
                  this.fail("parseFrom: expected comma", fromTok.lineno, fromTok.colno);
                }
                var name = this.parsePrimary();
                if (name.value.charAt(0) === "_") {
                  this.fail("parseFrom: names starting with an underscore cannot be imported", name.lineno, name.colno);
                }
                if (this.skipSymbol("as")) {
                  var alias = this.parsePrimary();
                  names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
                } else {
                  names.addChild(name);
                }
                withContext = this.parseWithContext();
              }
              return new nodes.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
            };
            _proto.parseBlock = function parseBlock() {
              var tag = this.peekToken();
              if (!this.skipSymbol("block")) {
                this.fail("parseBlock: expected block", tag.lineno, tag.colno);
              }
              var node = new nodes.Block(tag.lineno, tag.colno);
              node.name = this.parsePrimary();
              if (!(node.name instanceof nodes.Symbol)) {
                this.fail("parseBlock: variable name expected", tag.lineno, tag.colno);
              }
              this.advanceAfterBlockEnd(tag.value);
              node.body = this.parseUntilBlocks("endblock");
              this.skipSymbol("endblock");
              this.skipSymbol(node.name.value);
              var tok = this.peekToken();
              if (!tok) {
                this.fail("parseBlock: expected endblock, got end of file");
              }
              this.advanceAfterBlockEnd(tok.value);
              return node;
            };
            _proto.parseExtends = function parseExtends() {
              var tagName = "extends";
              var tag = this.peekToken();
              if (!this.skipSymbol(tagName)) {
                this.fail("parseTemplateRef: expected " + tagName);
              }
              var node = new nodes.Extends(tag.lineno, tag.colno);
              node.template = this.parseExpression();
              this.advanceAfterBlockEnd(tag.value);
              return node;
            };
            _proto.parseInclude = function parseInclude() {
              var tagName = "include";
              var tag = this.peekToken();
              if (!this.skipSymbol(tagName)) {
                this.fail("parseInclude: expected " + tagName);
              }
              var node = new nodes.Include(tag.lineno, tag.colno);
              node.template = this.parseExpression();
              if (this.skipSymbol("ignore") && this.skipSymbol("missing")) {
                node.ignoreMissing = true;
              }
              this.advanceAfterBlockEnd(tag.value);
              return node;
            };
            _proto.parseIf = function parseIf() {
              var tag = this.peekToken();
              var node;
              if (this.skipSymbol("if") || this.skipSymbol("elif") || this.skipSymbol("elseif")) {
                node = new nodes.If(tag.lineno, tag.colno);
              } else if (this.skipSymbol("ifAsync")) {
                node = new nodes.IfAsync(tag.lineno, tag.colno);
              } else {
                this.fail("parseIf: expected if, elif, or elseif", tag.lineno, tag.colno);
              }
              node.cond = this.parseExpression();
              this.advanceAfterBlockEnd(tag.value);
              node.body = this.parseUntilBlocks("elif", "elseif", "else", "endif");
              var tok = this.peekToken();
              switch (tok && tok.value) {
                case "elseif":
                case "elif":
                  node.else_ = this.parseIf();
                  break;
                case "else":
                  this.advanceAfterBlockEnd();
                  node.else_ = this.parseUntilBlocks("endif");
                  this.advanceAfterBlockEnd();
                  break;
                case "endif":
                  node.else_ = null;
                  this.advanceAfterBlockEnd();
                  break;
                default:
                  this.fail("parseIf: expected elif, else, or endif, got end of file");
              }
              return node;
            };
            _proto.parseSet = function parseSet() {
              var tag = this.peekToken();
              if (!this.skipSymbol("set")) {
                this.fail("parseSet: expected set", tag.lineno, tag.colno);
              }
              var node = new nodes.Set(tag.lineno, tag.colno, []);
              var target;
              while (target = this.parsePrimary()) {
                node.targets.push(target);
                if (!this.skip(lexer.TOKEN_COMMA)) {
                  break;
                }
              }
              if (!this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
                if (!this.skip(lexer.TOKEN_BLOCK_END)) {
                  this.fail("parseSet: expected = or block end in set tag", tag.lineno, tag.colno);
                } else {
                  node.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks("endset"));
                  node.value = null;
                  this.advanceAfterBlockEnd();
                }
              } else {
                node.value = this.parseExpression();
                this.advanceAfterBlockEnd(tag.value);
              }
              return node;
            };
            _proto.parseSwitch = function parseSwitch() {
              var switchStart = "switch";
              var switchEnd = "endswitch";
              var caseStart = "case";
              var caseDefault = "default";
              var tag = this.peekToken();
              if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
                this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
              }
              var expr = this.parseExpression();
              this.advanceAfterBlockEnd(switchStart);
              this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
              var tok = this.peekToken();
              var cases = [];
              var defaultCase;
              do {
                this.skipSymbol(caseStart);
                var cond = this.parseExpression();
                this.advanceAfterBlockEnd(switchStart);
                var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
                cases.push(new nodes.Case(tok.line, tok.col, cond, body));
                tok = this.peekToken();
              } while (tok && tok.value === caseStart);
              switch (tok.value) {
                case caseDefault:
                  this.advanceAfterBlockEnd();
                  defaultCase = this.parseUntilBlocks(switchEnd);
                  this.advanceAfterBlockEnd();
                  break;
                case switchEnd:
                  this.advanceAfterBlockEnd();
                  break;
                default:
                  this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
              }
              return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
            };
            _proto.parseStatement = function parseStatement() {
              var tok = this.peekToken();
              var node;
              if (tok.type !== lexer.TOKEN_SYMBOL) {
                this.fail("tag name expected", tok.lineno, tok.colno);
              }
              if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
                return null;
              }
              switch (tok.value) {
                case "raw":
                  return this.parseRaw();
                case "verbatim":
                  return this.parseRaw("verbatim");
                case "if":
                case "ifAsync":
                  return this.parseIf();
                case "for":
                case "asyncEach":
                case "asyncAll":
                  return this.parseFor();
                case "block":
                  return this.parseBlock();
                case "extends":
                  return this.parseExtends();
                case "include":
                  return this.parseInclude();
                case "set":
                  return this.parseSet();
                case "macro":
                  return this.parseMacro();
                case "call":
                  return this.parseCall();
                case "import":
                  return this.parseImport();
                case "from":
                  return this.parseFrom();
                case "filter":
                  return this.parseFilterStatement();
                case "switch":
                  return this.parseSwitch();
                default:
                  if (this.extensions.length) {
                    for (var i = 0; i < this.extensions.length; i++) {
                      var ext = this.extensions[i];
                      if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
                        return ext.parse(this, nodes, lexer);
                      }
                    }
                  }
                  this.fail("unknown block tag: " + tok.value, tok.lineno, tok.colno);
              }
              return node;
            };
            _proto.parseRaw = function parseRaw(tagName) {
              tagName = tagName || "raw";
              var endTagName = "end" + tagName;
              var rawBlockRegex = new RegExp("([\\s\\S]*?){%\\s*(" + tagName + "|" + endTagName + ")\\s*(?=%})%}");
              var rawLevel = 1;
              var str = "";
              var matches = null;
              var begun = this.advanceAfterBlockEnd();
              while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
                var all = matches[0];
                var pre = matches[1];
                var blockName = matches[2];
                if (blockName === tagName) {
                  rawLevel += 1;
                } else if (blockName === endTagName) {
                  rawLevel -= 1;
                }
                if (rawLevel === 0) {
                  str += pre;
                  this.tokens.backN(all.length - pre.length);
                } else {
                  str += all;
                }
              }
              return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
            };
            _proto.parsePostfix = function parsePostfix(node) {
              var lookup;
              var tok = this.peekToken();
              while (tok) {
                if (tok.type === lexer.TOKEN_LEFT_PAREN) {
                  node = new nodes.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
                } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
                  lookup = this.parseAggregate();
                  if (lookup.children.length > 1) {
                    this.fail("invalid index");
                  }
                  node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
                } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === ".") {
                  this.nextToken();
                  var val = this.nextToken();
                  if (val.type !== lexer.TOKEN_SYMBOL) {
                    this.fail("expected name as lookup value, got " + val.value, val.lineno, val.colno);
                  }
                  lookup = new nodes.Literal(val.lineno, val.colno, val.value);
                  node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup);
                } else {
                  break;
                }
                tok = this.peekToken();
              }
              return node;
            };
            _proto.parseExpression = function parseExpression() {
              var node = this.parseInlineIf();
              return node;
            };
            _proto.parseInlineIf = function parseInlineIf() {
              var node = this.parseOr();
              if (this.skipSymbol("if")) {
                var condNode = this.parseOr();
                var bodyNode = node;
                node = new nodes.InlineIf(node.lineno, node.colno);
                node.body = bodyNode;
                node.cond = condNode;
                if (this.skipSymbol("else")) {
                  node.else_ = this.parseOr();
                } else {
                  node.else_ = null;
                }
              }
              return node;
            };
            _proto.parseOr = function parseOr() {
              var node = this.parseAnd();
              while (this.skipSymbol("or")) {
                var node2 = this.parseAnd();
                node = new nodes.Or(node.lineno, node.colno, node, node2);
              }
              return node;
            };
            _proto.parseAnd = function parseAnd() {
              var node = this.parseNot();
              while (this.skipSymbol("and")) {
                var node2 = this.parseNot();
                node = new nodes.And(node.lineno, node.colno, node, node2);
              }
              return node;
            };
            _proto.parseNot = function parseNot() {
              var tok = this.peekToken();
              if (this.skipSymbol("not")) {
                return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
              }
              return this.parseIn();
            };
            _proto.parseIn = function parseIn() {
              var node = this.parseIs();
              while (1) {
                var tok = this.nextToken();
                if (!tok) {
                  break;
                }
                var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === "not";
                if (!invert) {
                  this.pushToken(tok);
                }
                if (this.skipSymbol("in")) {
                  var node2 = this.parseIs();
                  node = new nodes.In(node.lineno, node.colno, node, node2);
                  if (invert) {
                    node = new nodes.Not(node.lineno, node.colno, node);
                  }
                } else {
                  if (invert) {
                    this.pushToken(tok);
                  }
                  break;
                }
              }
              return node;
            };
            _proto.parseIs = function parseIs() {
              var node = this.parseCompare();
              if (this.skipSymbol("is")) {
                var not = this.skipSymbol("not");
                var node2 = this.parseCompare();
                node = new nodes.Is(node.lineno, node.colno, node, node2);
                if (not) {
                  node = new nodes.Not(node.lineno, node.colno, node);
                }
              }
              return node;
            };
            _proto.parseCompare = function parseCompare() {
              var compareOps = ["==", "===", "!=", "!==", "<", ">", "<=", ">="];
              var expr = this.parseConcat();
              var ops = [];
              while (1) {
                var tok = this.nextToken();
                if (!tok) {
                  break;
                } else if (compareOps.indexOf(tok.value) !== -1) {
                  ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
                } else {
                  this.pushToken(tok);
                  break;
                }
              }
              if (ops.length) {
                return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
              } else {
                return expr;
              }
            };
            _proto.parseConcat = function parseConcat() {
              var node = this.parseAdd();
              while (this.skipValue(lexer.TOKEN_TILDE, "~")) {
                var node2 = this.parseAdd();
                node = new nodes.Concat(node.lineno, node.colno, node, node2);
              }
              return node;
            };
            _proto.parseAdd = function parseAdd() {
              var node = this.parseSub();
              while (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
                var node2 = this.parseSub();
                node = new nodes.Add(node.lineno, node.colno, node, node2);
              }
              return node;
            };
            _proto.parseSub = function parseSub() {
              var node = this.parseMul();
              while (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
                var node2 = this.parseMul();
                node = new nodes.Sub(node.lineno, node.colno, node, node2);
              }
              return node;
            };
            _proto.parseMul = function parseMul() {
              var node = this.parseDiv();
              while (this.skipValue(lexer.TOKEN_OPERATOR, "*")) {
                var node2 = this.parseDiv();
                node = new nodes.Mul(node.lineno, node.colno, node, node2);
              }
              return node;
            };
            _proto.parseDiv = function parseDiv() {
              var node = this.parseFloorDiv();
              while (this.skipValue(lexer.TOKEN_OPERATOR, "/")) {
                var node2 = this.parseFloorDiv();
                node = new nodes.Div(node.lineno, node.colno, node, node2);
              }
              return node;
            };
            _proto.parseFloorDiv = function parseFloorDiv() {
              var node = this.parseMod();
              while (this.skipValue(lexer.TOKEN_OPERATOR, "//")) {
                var node2 = this.parseMod();
                node = new nodes.FloorDiv(node.lineno, node.colno, node, node2);
              }
              return node;
            };
            _proto.parseMod = function parseMod() {
              var node = this.parsePow();
              while (this.skipValue(lexer.TOKEN_OPERATOR, "%")) {
                var node2 = this.parsePow();
                node = new nodes.Mod(node.lineno, node.colno, node, node2);
              }
              return node;
            };
            _proto.parsePow = function parsePow() {
              var node = this.parseUnary();
              while (this.skipValue(lexer.TOKEN_OPERATOR, "**")) {
                var node2 = this.parseUnary();
                node = new nodes.Pow(node.lineno, node.colno, node, node2);
              }
              return node;
            };
            _proto.parseUnary = function parseUnary(noFilters) {
              var tok = this.peekToken();
              var node;
              if (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
                node = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
              } else if (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
                node = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
              } else {
                node = this.parsePrimary();
              }
              if (!noFilters) {
                node = this.parseFilter(node);
              }
              return node;
            };
            _proto.parsePrimary = function parsePrimary(noPostfix) {
              var tok = this.nextToken();
              var val;
              var node = null;
              if (!tok) {
                this.fail("expected expression, got end of file");
              } else if (tok.type === lexer.TOKEN_STRING) {
                val = tok.value;
              } else if (tok.type === lexer.TOKEN_INT) {
                val = parseInt(tok.value, 10);
              } else if (tok.type === lexer.TOKEN_FLOAT) {
                val = parseFloat(tok.value);
              } else if (tok.type === lexer.TOKEN_BOOLEAN) {
                if (tok.value === "true") {
                  val = true;
                } else if (tok.value === "false") {
                  val = false;
                } else {
                  this.fail("invalid boolean: " + tok.value, tok.lineno, tok.colno);
                }
              } else if (tok.type === lexer.TOKEN_NONE) {
                val = null;
              } else if (tok.type === lexer.TOKEN_REGEX) {
                val = new RegExp(tok.value.body, tok.value.flags);
              }
              if (val !== void 0) {
                node = new nodes.Literal(tok.lineno, tok.colno, val);
              } else if (tok.type === lexer.TOKEN_SYMBOL) {
                node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
              } else {
                this.pushToken(tok);
                node = this.parseAggregate();
              }
              if (!noPostfix) {
                node = this.parsePostfix(node);
              }
              if (node) {
                return node;
              } else {
                throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
              }
            };
            _proto.parseFilterName = function parseFilterName() {
              var tok = this.expect(lexer.TOKEN_SYMBOL);
              var name = tok.value;
              while (this.skipValue(lexer.TOKEN_OPERATOR, ".")) {
                name += "." + this.expect(lexer.TOKEN_SYMBOL).value;
              }
              return new nodes.Symbol(tok.lineno, tok.colno, name);
            };
            _proto.parseFilterArgs = function parseFilterArgs(node) {
              if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
                var call = this.parsePostfix(node);
                return call.args.children;
              }
              return [];
            };
            _proto.parseFilter = function parseFilter(node) {
              while (this.skip(lexer.TOKEN_PIPE)) {
                var name = this.parseFilterName();
                node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node].concat(this.parseFilterArgs(node))));
              }
              return node;
            };
            _proto.parseFilterStatement = function parseFilterStatement() {
              var filterTok = this.peekToken();
              if (!this.skipSymbol("filter")) {
                this.fail("parseFilterStatement: expected filter");
              }
              var name = this.parseFilterName();
              var args = this.parseFilterArgs(name);
              this.advanceAfterBlockEnd(filterTok.value);
              var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks("endfilter"));
              this.advanceAfterBlockEnd();
              var node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
              return new nodes.Output(name.lineno, name.colno, [node]);
            };
            _proto.parseAggregate = function parseAggregate() {
              var tok = this.nextToken();
              var node;
              switch (tok.type) {
                case lexer.TOKEN_LEFT_PAREN:
                  node = new nodes.Group(tok.lineno, tok.colno);
                  break;
                case lexer.TOKEN_LEFT_BRACKET:
                  node = new nodes.Array(tok.lineno, tok.colno);
                  break;
                case lexer.TOKEN_LEFT_CURLY:
                  node = new nodes.Dict(tok.lineno, tok.colno);
                  break;
                default:
                  return null;
              }
              while (1) {
                var type = this.peekToken().type;
                if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
                  this.nextToken();
                  break;
                }
                if (node.children.length > 0) {
                  if (!this.skip(lexer.TOKEN_COMMA)) {
                    this.fail("parseAggregate: expected comma after expression", tok.lineno, tok.colno);
                  }
                }
                if (node instanceof nodes.Dict) {
                  var key = this.parsePrimary();
                  if (!this.skip(lexer.TOKEN_COLON)) {
                    this.fail("parseAggregate: expected colon after dict key", tok.lineno, tok.colno);
                  }
                  var value = this.parseExpression();
                  node.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
                } else {
                  var expr = this.parseExpression();
                  node.addChild(expr);
                }
              }
              return node;
            };
            _proto.parseSignature = function parseSignature(tolerant, noParens) {
              var tok = this.peekToken();
              if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
                if (tolerant) {
                  return null;
                } else {
                  this.fail("expected arguments", tok.lineno, tok.colno);
                }
              }
              if (tok.type === lexer.TOKEN_LEFT_PAREN) {
                tok = this.nextToken();
              }
              var args = new nodes.NodeList(tok.lineno, tok.colno);
              var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
              var checkComma = false;
              while (1) {
                tok = this.peekToken();
                if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
                  this.nextToken();
                  break;
                } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
                  break;
                }
                if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
                  this.fail("parseSignature: expected comma after expression", tok.lineno, tok.colno);
                } else {
                  var arg = this.parseExpression();
                  if (this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
                    kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
                  } else {
                    args.addChild(arg);
                  }
                }
                checkComma = true;
              }
              if (kwargs.children.length) {
                args.addChild(kwargs);
              }
              return args;
            };
            _proto.parseUntilBlocks = function parseUntilBlocks() {
              var prev = this.breakOnBlocks;
              for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
                blockNames[_key] = arguments[_key];
              }
              this.breakOnBlocks = blockNames;
              var ret = this.parse();
              this.breakOnBlocks = prev;
              return ret;
            };
            _proto.parseNodes = function parseNodes() {
              var tok;
              var buf = [];
              while (tok = this.nextToken()) {
                if (tok.type === lexer.TOKEN_DATA) {
                  var data = tok.value;
                  var nextToken = this.peekToken();
                  var nextVal = nextToken && nextToken.value;
                  if (this.dropLeadingWhitespace) {
                    data = data.replace(/^\s*/, "");
                    this.dropLeadingWhitespace = false;
                  }
                  if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === "-" || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === "-" || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === "-")) {
                    data = data.replace(/\s*$/, "");
                  }
                  buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
                } else if (tok.type === lexer.TOKEN_BLOCK_START) {
                  this.dropLeadingWhitespace = false;
                  var n = this.parseStatement();
                  if (!n) {
                    break;
                  }
                  buf.push(n);
                } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
                  var e = this.parseExpression();
                  this.dropLeadingWhitespace = false;
                  this.advanceAfterVariableEnd();
                  buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
                } else if (tok.type === lexer.TOKEN_COMMENT) {
                  this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === "-";
                } else {
                  this.fail("Unexpected token at top-level: " + tok.type, tok.lineno, tok.colno);
                }
              }
              return buf;
            };
            _proto.parse = function parse() {
              return new nodes.NodeList(0, 0, this.parseNodes());
            };
            _proto.parseAsRoot = function parseAsRoot() {
              return new nodes.Root(0, 0, this.parseNodes());
            };
            return Parser2;
          }(Obj);
          module3.exports = {
            parse: function parse(src, extensions, opts) {
              var p = new Parser(lexer.lex(src, opts));
              if (extensions !== void 0) {
                p.extensions = extensions;
              }
              return p.parseAsRoot();
            },
            Parser
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var lib = __webpack_require__(0);
          var whitespaceChars = " \n	\r\xA0";
          var delimChars = "()[]{}%*-+~/#,:|.<>=!";
          var intChars = "0123456789";
          var BLOCK_START = "{%";
          var BLOCK_END = "%}";
          var VARIABLE_START = "{{";
          var VARIABLE_END = "}}";
          var COMMENT_START = "{#";
          var COMMENT_END = "#}";
          var TOKEN_STRING = "string";
          var TOKEN_WHITESPACE = "whitespace";
          var TOKEN_DATA = "data";
          var TOKEN_BLOCK_START = "block-start";
          var TOKEN_BLOCK_END = "block-end";
          var TOKEN_VARIABLE_START = "variable-start";
          var TOKEN_VARIABLE_END = "variable-end";
          var TOKEN_COMMENT = "comment";
          var TOKEN_LEFT_PAREN = "left-paren";
          var TOKEN_RIGHT_PAREN = "right-paren";
          var TOKEN_LEFT_BRACKET = "left-bracket";
          var TOKEN_RIGHT_BRACKET = "right-bracket";
          var TOKEN_LEFT_CURLY = "left-curly";
          var TOKEN_RIGHT_CURLY = "right-curly";
          var TOKEN_OPERATOR = "operator";
          var TOKEN_COMMA = "comma";
          var TOKEN_COLON = "colon";
          var TOKEN_TILDE = "tilde";
          var TOKEN_PIPE = "pipe";
          var TOKEN_INT = "int";
          var TOKEN_FLOAT = "float";
          var TOKEN_BOOLEAN = "boolean";
          var TOKEN_NONE = "none";
          var TOKEN_SYMBOL = "symbol";
          var TOKEN_SPECIAL = "special";
          var TOKEN_REGEX = "regex";
          function token(type, value, lineno, colno) {
            return {
              type,
              value,
              lineno,
              colno
            };
          }
          var Tokenizer = /* @__PURE__ */ function() {
            function Tokenizer2(str, opts) {
              this.str = str;
              this.index = 0;
              this.len = str.length;
              this.lineno = 0;
              this.colno = 0;
              this.in_code = false;
              opts = opts || {};
              var tags = opts.tags || {};
              this.tags = {
                BLOCK_START: tags.blockStart || BLOCK_START,
                BLOCK_END: tags.blockEnd || BLOCK_END,
                VARIABLE_START: tags.variableStart || VARIABLE_START,
                VARIABLE_END: tags.variableEnd || VARIABLE_END,
                COMMENT_START: tags.commentStart || COMMENT_START,
                COMMENT_END: tags.commentEnd || COMMENT_END
              };
              this.trimBlocks = !!opts.trimBlocks;
              this.lstripBlocks = !!opts.lstripBlocks;
            }
            var _proto = Tokenizer2.prototype;
            _proto.nextToken = function nextToken() {
              var lineno = this.lineno;
              var colno = this.colno;
              var tok;
              if (this.in_code) {
                var cur = this.current();
                if (this.isFinished()) {
                  return null;
                } else if (cur === '"' || cur === "'") {
                  return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
                } else if (tok = this._extract(whitespaceChars)) {
                  return token(TOKEN_WHITESPACE, tok, lineno, colno);
                } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString("-" + this.tags.BLOCK_END))) {
                  this.in_code = false;
                  if (this.trimBlocks) {
                    cur = this.current();
                    if (cur === "\n") {
                      this.forward();
                    } else if (cur === "\r") {
                      this.forward();
                      cur = this.current();
                      if (cur === "\n") {
                        this.forward();
                      } else {
                        this.back();
                      }
                    }
                  }
                  return token(TOKEN_BLOCK_END, tok, lineno, colno);
                } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString("-" + this.tags.VARIABLE_END))) {
                  this.in_code = false;
                  return token(TOKEN_VARIABLE_END, tok, lineno, colno);
                } else if (cur === "r" && this.str.charAt(this.index + 1) === "/") {
                  this.forwardN(2);
                  var regexBody = "";
                  while (!this.isFinished()) {
                    if (this.current() === "/" && this.previous() !== "\\") {
                      this.forward();
                      break;
                    } else {
                      regexBody += this.current();
                      this.forward();
                    }
                  }
                  var POSSIBLE_FLAGS = ["g", "i", "m", "y"];
                  var regexFlags = "";
                  while (!this.isFinished()) {
                    var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;
                    if (isCurrentAFlag) {
                      regexFlags += this.current();
                      this.forward();
                    } else {
                      break;
                    }
                  }
                  return token(TOKEN_REGEX, {
                    body: regexBody,
                    flags: regexFlags
                  }, lineno, colno);
                } else if (delimChars.indexOf(cur) !== -1) {
                  this.forward();
                  var complexOps = ["==", "===", "!=", "!==", "<=", ">=", "//", "**"];
                  var curComplex = cur + this.current();
                  var type;
                  if (lib.indexOf(complexOps, curComplex) !== -1) {
                    this.forward();
                    cur = curComplex;
                    if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
                      cur = curComplex + this.current();
                      this.forward();
                    }
                  }
                  switch (cur) {
                    case "(":
                      type = TOKEN_LEFT_PAREN;
                      break;
                    case ")":
                      type = TOKEN_RIGHT_PAREN;
                      break;
                    case "[":
                      type = TOKEN_LEFT_BRACKET;
                      break;
                    case "]":
                      type = TOKEN_RIGHT_BRACKET;
                      break;
                    case "{":
                      type = TOKEN_LEFT_CURLY;
                      break;
                    case "}":
                      type = TOKEN_RIGHT_CURLY;
                      break;
                    case ",":
                      type = TOKEN_COMMA;
                      break;
                    case ":":
                      type = TOKEN_COLON;
                      break;
                    case "~":
                      type = TOKEN_TILDE;
                      break;
                    case "|":
                      type = TOKEN_PIPE;
                      break;
                    default:
                      type = TOKEN_OPERATOR;
                  }
                  return token(type, cur, lineno, colno);
                } else {
                  tok = this._extractUntil(whitespaceChars + delimChars);
                  if (tok.match(/^[-+]?[0-9]+$/)) {
                    if (this.current() === ".") {
                      this.forward();
                      var dec = this._extract(intChars);
                      return token(TOKEN_FLOAT, tok + "." + dec, lineno, colno);
                    } else {
                      return token(TOKEN_INT, tok, lineno, colno);
                    }
                  } else if (tok.match(/^(true|false)$/)) {
                    return token(TOKEN_BOOLEAN, tok, lineno, colno);
                  } else if (tok === "none") {
                    return token(TOKEN_NONE, tok, lineno, colno);
                  } else if (tok === "null") {
                    return token(TOKEN_NONE, tok, lineno, colno);
                  } else if (tok) {
                    return token(TOKEN_SYMBOL, tok, lineno, colno);
                  } else {
                    throw new Error("Unexpected value while parsing: " + tok);
                  }
                }
              } else {
                var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);
                if (this.isFinished()) {
                  return null;
                } else if ((tok = this._extractString(this.tags.BLOCK_START + "-")) || (tok = this._extractString(this.tags.BLOCK_START))) {
                  this.in_code = true;
                  return token(TOKEN_BLOCK_START, tok, lineno, colno);
                } else if ((tok = this._extractString(this.tags.VARIABLE_START + "-")) || (tok = this._extractString(this.tags.VARIABLE_START))) {
                  this.in_code = true;
                  return token(TOKEN_VARIABLE_START, tok, lineno, colno);
                } else {
                  tok = "";
                  var data;
                  var inComment = false;
                  if (this._matches(this.tags.COMMENT_START)) {
                    inComment = true;
                    tok = this._extractString(this.tags.COMMENT_START);
                  }
                  while ((data = this._extractUntil(beginChars)) !== null) {
                    tok += data;
                    if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
                      if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
                        var lastLine = tok.slice(-this.colno);
                        if (/^\s+$/.test(lastLine)) {
                          tok = tok.slice(0, -this.colno);
                          if (!tok.length) {
                            return this.nextToken();
                          }
                        }
                      }
                      break;
                    } else if (this._matches(this.tags.COMMENT_END)) {
                      if (!inComment) {
                        throw new Error("unexpected end of comment");
                      }
                      tok += this._extractString(this.tags.COMMENT_END);
                      break;
                    } else {
                      tok += this.current();
                      this.forward();
                    }
                  }
                  if (data === null && inComment) {
                    throw new Error("expected end of comment, got end of file");
                  }
                  return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
                }
              }
            };
            _proto._parseString = function _parseString(delimiter) {
              this.forward();
              var str = "";
              while (!this.isFinished() && this.current() !== delimiter) {
                var cur = this.current();
                if (cur === "\\") {
                  this.forward();
                  switch (this.current()) {
                    case "n":
                      str += "\n";
                      break;
                    case "t":
                      str += "	";
                      break;
                    case "r":
                      str += "\r";
                      break;
                    default:
                      str += this.current();
                  }
                  this.forward();
                } else {
                  str += cur;
                  this.forward();
                }
              }
              this.forward();
              return str;
            };
            _proto._matches = function _matches(str) {
              if (this.index + str.length > this.len) {
                return null;
              }
              var m = this.str.slice(this.index, this.index + str.length);
              return m === str;
            };
            _proto._extractString = function _extractString(str) {
              if (this._matches(str)) {
                this.forwardN(str.length);
                return str;
              }
              return null;
            };
            _proto._extractUntil = function _extractUntil(charString) {
              return this._extractMatching(true, charString || "");
            };
            _proto._extract = function _extract(charString) {
              return this._extractMatching(false, charString);
            };
            _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
              if (this.isFinished()) {
                return null;
              }
              var first = charString.indexOf(this.current());
              if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
                var t = this.current();
                this.forward();
                var idx = charString.indexOf(this.current());
                while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
                  t += this.current();
                  this.forward();
                  idx = charString.indexOf(this.current());
                }
                return t;
              }
              return "";
            };
            _proto._extractRegex = function _extractRegex(regex) {
              var matches = this.currentStr().match(regex);
              if (!matches) {
                return null;
              }
              this.forwardN(matches[0].length);
              return matches;
            };
            _proto.isFinished = function isFinished() {
              return this.index >= this.len;
            };
            _proto.forwardN = function forwardN(n) {
              for (var i = 0; i < n; i++) {
                this.forward();
              }
            };
            _proto.forward = function forward() {
              this.index++;
              if (this.previous() === "\n") {
                this.lineno++;
                this.colno = 0;
              } else {
                this.colno++;
              }
            };
            _proto.backN = function backN(n) {
              for (var i = 0; i < n; i++) {
                this.back();
              }
            };
            _proto.back = function back() {
              this.index--;
              if (this.current() === "\n") {
                this.lineno--;
                var idx = this.src.lastIndexOf("\n", this.index - 1);
                if (idx === -1) {
                  this.colno = this.index;
                } else {
                  this.colno = this.index - idx;
                }
              } else {
                this.colno--;
              }
            };
            _proto.current = function current() {
              if (!this.isFinished()) {
                return this.str.charAt(this.index);
              }
              return "";
            };
            _proto.currentStr = function currentStr() {
              if (!this.isFinished()) {
                return this.str.substr(this.index);
              }
              return "";
            };
            _proto.previous = function previous() {
              return this.str.charAt(this.index - 1);
            };
            return Tokenizer2;
          }();
          module3.exports = {
            lex: function lex(src, opts) {
              return new Tokenizer(src, opts);
            },
            TOKEN_STRING,
            TOKEN_WHITESPACE,
            TOKEN_DATA,
            TOKEN_BLOCK_START,
            TOKEN_BLOCK_END,
            TOKEN_VARIABLE_START,
            TOKEN_VARIABLE_END,
            TOKEN_COMMENT,
            TOKEN_LEFT_PAREN,
            TOKEN_RIGHT_PAREN,
            TOKEN_LEFT_BRACKET,
            TOKEN_RIGHT_BRACKET,
            TOKEN_LEFT_CURLY,
            TOKEN_RIGHT_CURLY,
            TOKEN_OPERATOR,
            TOKEN_COMMA,
            TOKEN_COLON,
            TOKEN_TILDE,
            TOKEN_PIPE,
            TOKEN_INT,
            TOKEN_FLOAT,
            TOKEN_BOOLEAN,
            TOKEN_NONE,
            TOKEN_SYMBOL,
            TOKEN_SPECIAL,
            TOKEN_REGEX
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          var Loader = __webpack_require__(6);
          var _require = __webpack_require__(19), PrecompiledLoader = _require.PrecompiledLoader;
          var WebLoader = /* @__PURE__ */ function(_Loader) {
            _inheritsLoose(WebLoader2, _Loader);
            function WebLoader2(baseURL, opts) {
              var _this;
              _this = _Loader.call(this) || this;
              _this.baseURL = baseURL || ".";
              opts = opts || {};
              _this.useCache = !!opts.useCache;
              _this.async = !!opts.async;
              return _this;
            }
            var _proto = WebLoader2.prototype;
            _proto.resolve = function resolve(from, to) {
              throw new Error("relative templates not support in the browser yet");
            };
            _proto.getSource = function getSource(name, cb) {
              var _this2 = this;
              var useCache = this.useCache;
              var result;
              this.fetch(this.baseURL + "/" + name, function(err, src) {
                if (err) {
                  if (cb) {
                    cb(err.content);
                  } else if (err.status === 404) {
                    result = null;
                  } else {
                    throw err.content;
                  }
                } else {
                  result = {
                    src,
                    path: name,
                    noCache: !useCache
                  };
                  _this2.emit("load", name, result);
                  if (cb) {
                    cb(null, result);
                  }
                }
              });
              return result;
            };
            _proto.fetch = function fetch(url, cb) {
              if (typeof window === "undefined") {
                throw new Error("WebLoader can only by used in a browser");
              }
              var ajax = new XMLHttpRequest();
              var loading = true;
              ajax.onreadystatechange = function() {
                if (ajax.readyState === 4 && loading) {
                  loading = false;
                  if (ajax.status === 0 || ajax.status === 200) {
                    cb(null, ajax.responseText);
                  } else {
                    cb({
                      status: ajax.status,
                      content: ajax.responseText
                    });
                  }
                }
              };
              url += (url.indexOf("?") === -1 ? "?" : "&") + "s=" + new Date().getTime();
              ajax.open("GET", url, this.async);
              ajax.send();
            };
            return WebLoader2;
          }(Loader);
          module3.exports = {
            WebLoader,
            PrecompiledLoader
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var lib = __webpack_require__(0);
          var _require = __webpack_require__(7), Environment = _require.Environment, Template = _require.Template;
          var Loader = __webpack_require__(6);
          var loaders = __webpack_require__(10);
          var precompile = __webpack_require__(23);
          var compiler = __webpack_require__(5);
          var parser = __webpack_require__(8);
          var lexer = __webpack_require__(9);
          var runtime = __webpack_require__(2);
          var nodes = __webpack_require__(3);
          var installJinjaCompat = __webpack_require__(25);
          var e;
          function configure(templatesPath, opts) {
            opts = opts || {};
            if (lib.isObject(templatesPath)) {
              opts = templatesPath;
              templatesPath = null;
            }
            var TemplateLoader;
            if (loaders.FileSystemLoader) {
              TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
                watch: opts.watch,
                noCache: opts.noCache
              });
            } else if (loaders.WebLoader) {
              TemplateLoader = new loaders.WebLoader(templatesPath, {
                useCache: opts.web && opts.web.useCache,
                async: opts.web && opts.web.async
              });
            }
            e = new Environment(TemplateLoader, opts);
            if (opts && opts.express) {
              e.express(opts.express);
            }
            return e;
          }
          module3.exports = {
            Environment,
            Template,
            Loader,
            FileSystemLoader: loaders.FileSystemLoader,
            NodeResolveLoader: loaders.NodeResolveLoader,
            PrecompiledLoader: loaders.PrecompiledLoader,
            WebLoader: loaders.WebLoader,
            compiler,
            parser,
            lexer,
            runtime,
            lib,
            nodes,
            installJinjaCompat,
            configure,
            reset: function reset() {
              e = void 0;
            },
            compile: function compile(src, env, path, eagerCompile) {
              if (!e) {
                configure();
              }
              return new Template(src, env, path, eagerCompile);
            },
            render: function render(name, ctx, cb) {
              if (!e) {
                configure();
              }
              return e.render(name, ctx, cb);
            },
            renderString: function renderString(src, ctx, cb) {
              if (!e) {
                configure();
              }
              return e.renderString(src, ctx, cb);
            },
            precompile: precompile ? precompile.precompile : void 0,
            precompileString: precompile ? precompile.precompileString : void 0
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var rawAsap = __webpack_require__(13);
          var freeTasks = [];
          var pendingErrors = [];
          var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
          function throwFirstError() {
            if (pendingErrors.length) {
              throw pendingErrors.shift();
            }
          }
          module3.exports = asap;
          function asap(task) {
            var rawTask;
            if (freeTasks.length) {
              rawTask = freeTasks.pop();
            } else {
              rawTask = new RawTask();
            }
            rawTask.task = task;
            rawAsap(rawTask);
          }
          function RawTask() {
            this.task = null;
          }
          RawTask.prototype.call = function() {
            try {
              this.task.call();
            } catch (error) {
              if (asap.onerror) {
                asap.onerror(error);
              } else {
                pendingErrors.push(error);
                requestErrorThrow();
              }
            } finally {
              this.task = null;
              freeTasks[freeTasks.length] = this;
            }
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          (function(global2) {
            module3.exports = rawAsap;
            function rawAsap(task) {
              if (!queue.length) {
                requestFlush();
                flushing = true;
              }
              queue[queue.length] = task;
            }
            var queue = [];
            var flushing = false;
            var requestFlush;
            var index = 0;
            var capacity = 1024;
            function flush2() {
              while (index < queue.length) {
                var currentIndex = index;
                index = index + 1;
                queue[currentIndex].call();
                if (index > capacity) {
                  for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                    queue[scan] = queue[scan + index];
                  }
                  queue.length -= index;
                  index = 0;
                }
              }
              queue.length = 0;
              index = 0;
              flushing = false;
            }
            var scope = typeof global2 !== "undefined" ? global2 : self;
            var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
            if (typeof BrowserMutationObserver === "function") {
              requestFlush = makeRequestCallFromMutationObserver(flush2);
            } else {
              requestFlush = makeRequestCallFromTimer(flush2);
            }
            rawAsap.requestFlush = requestFlush;
            function makeRequestCallFromMutationObserver(callback) {
              var toggle = 1;
              var observer = new BrowserMutationObserver(callback);
              var node = document.createTextNode("");
              observer.observe(node, { characterData: true });
              return function requestCall() {
                toggle = -toggle;
                node.data = toggle;
              };
            }
            function makeRequestCallFromTimer(callback) {
              return function requestCall() {
                var timeoutHandle = setTimeout(handleTimer, 0);
                var intervalHandle = setInterval(handleTimer, 50);
                function handleTimer() {
                  clearTimeout(timeoutHandle);
                  clearInterval(intervalHandle);
                  callback();
                }
              };
            }
            rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
          }).call(exports2, __webpack_require__(14));
        },
        function(module3, exports2) {
          var g;
          g = function() {
            return this;
          }();
          try {
            g = g || Function("return this")() || (1, eval)("this");
          } catch (e) {
            if (typeof window === "object")
              g = window;
          }
          module3.exports = g;
        },
        function(module3, exports2, __webpack_require__) {
          var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          (function(globals2) {
            "use strict";
            var executeSync = function() {
              var args = Array.prototype.slice.call(arguments);
              if (typeof args[0] === "function") {
                args[0].apply(null, args.splice(1));
              }
            };
            var executeAsync = function(fn) {
              if (typeof setImmediate === "function") {
                setImmediate(fn);
              } else if (typeof process !== "undefined" && process.nextTick) {
                process.nextTick(fn);
              } else {
                setTimeout(fn, 0);
              }
            };
            var makeIterator = function(tasks) {
              var makeCallback = function(index) {
                var fn = function() {
                  if (tasks.length) {
                    tasks[index].apply(null, arguments);
                  }
                  return fn.next();
                };
                fn.next = function() {
                  return index < tasks.length - 1 ? makeCallback(index + 1) : null;
                };
                return fn;
              };
              return makeCallback(0);
            };
            var _isArray = Array.isArray || function(maybeArray) {
              return Object.prototype.toString.call(maybeArray) === "[object Array]";
            };
            var waterfall = function(tasks, callback, forceAsync) {
              var nextTick = forceAsync ? executeAsync : executeSync;
              callback = callback || function() {
              };
              if (!_isArray(tasks)) {
                var err = new Error("First argument to waterfall must be an array of functions");
                return callback(err);
              }
              if (!tasks.length) {
                return callback();
              }
              var wrapIterator = function(iterator) {
                return function(err2) {
                  if (err2) {
                    callback.apply(null, arguments);
                    callback = function() {
                    };
                  } else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                      args.push(wrapIterator(next));
                    } else {
                      args.push(callback);
                    }
                    nextTick(function() {
                      iterator.apply(null, args);
                    });
                  }
                };
              };
              wrapIterator(makeIterator(tasks))();
            };
            if (true) {
              !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return waterfall;
              }.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module3 !== "undefined" && module3.exports) {
              module3.exports = waterfall;
            } else {
              globals2.waterfall = waterfall;
            }
          })(this);
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var R = typeof Reflect === "object" ? Reflect : null;
          var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
            return Function.prototype.apply.call(target, receiver, args);
          };
          var ReflectOwnKeys;
          if (R && typeof R.ownKeys === "function") {
            ReflectOwnKeys = R.ownKeys;
          } else if (Object.getOwnPropertySymbols) {
            ReflectOwnKeys = function ReflectOwnKeys2(target) {
              return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
            };
          } else {
            ReflectOwnKeys = function ReflectOwnKeys2(target) {
              return Object.getOwnPropertyNames(target);
            };
          }
          function ProcessEmitWarning(warning) {
            if (console && console.warn)
              console.warn(warning);
          }
          var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
            return value !== value;
          };
          function EventEmitter() {
            EventEmitter.init.call(this);
          }
          module3.exports = EventEmitter;
          module3.exports.once = once;
          EventEmitter.EventEmitter = EventEmitter;
          EventEmitter.prototype._events = void 0;
          EventEmitter.prototype._eventsCount = 0;
          EventEmitter.prototype._maxListeners = void 0;
          var defaultMaxListeners = 10;
          function checkListener(listener) {
            if (typeof listener !== "function") {
              throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
            }
          }
          Object.defineProperty(EventEmitter, "defaultMaxListeners", {
            enumerable: true,
            get: function() {
              return defaultMaxListeners;
            },
            set: function(arg) {
              if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
              }
              defaultMaxListeners = arg;
            }
          });
          EventEmitter.init = function() {
            if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
              this._events = /* @__PURE__ */ Object.create(null);
              this._eventsCount = 0;
            }
            this._maxListeners = this._maxListeners || void 0;
          };
          EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
              throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
            }
            this._maxListeners = n;
            return this;
          };
          function _getMaxListeners(that) {
            if (that._maxListeners === void 0)
              return EventEmitter.defaultMaxListeners;
            return that._maxListeners;
          }
          EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return _getMaxListeners(this);
          };
          EventEmitter.prototype.emit = function emit(type) {
            var args = [];
            for (var i = 1; i < arguments.length; i++)
              args.push(arguments[i]);
            var doError = type === "error";
            var events = this._events;
            if (events !== void 0)
              doError = doError && events.error === void 0;
            else if (!doError)
              return false;
            if (doError) {
              var er;
              if (args.length > 0)
                er = args[0];
              if (er instanceof Error) {
                throw er;
              }
              var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
              err.context = er;
              throw err;
            }
            var handler = events[type];
            if (handler === void 0)
              return false;
            if (typeof handler === "function") {
              ReflectApply(handler, this, args);
            } else {
              var len = handler.length;
              var listeners = arrayClone(handler, len);
              for (var i = 0; i < len; ++i)
                ReflectApply(listeners[i], this, args);
            }
            return true;
          };
          function _addListener(target, type, listener, prepend) {
            var m;
            var events;
            var existing;
            checkListener(listener);
            events = target._events;
            if (events === void 0) {
              events = target._events = /* @__PURE__ */ Object.create(null);
              target._eventsCount = 0;
            } else {
              if (events.newListener !== void 0) {
                target.emit("newListener", type, listener.listener ? listener.listener : listener);
                events = target._events;
              }
              existing = events[type];
            }
            if (existing === void 0) {
              existing = events[type] = listener;
              ++target._eventsCount;
            } else {
              if (typeof existing === "function") {
                existing = events[type] = prepend ? [listener, existing] : [existing, listener];
              } else if (prepend) {
                existing.unshift(listener);
              } else {
                existing.push(listener);
              }
              m = _getMaxListeners(target);
              if (m > 0 && existing.length > m && !existing.warned) {
                existing.warned = true;
                var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                w.name = "MaxListenersExceededWarning";
                w.emitter = target;
                w.type = type;
                w.count = existing.length;
                ProcessEmitWarning(w);
              }
            }
            return target;
          }
          EventEmitter.prototype.addListener = function addListener(type, listener) {
            return _addListener(this, type, listener, false);
          };
          EventEmitter.prototype.on = EventEmitter.prototype.addListener;
          EventEmitter.prototype.prependListener = function prependListener(type, listener) {
            return _addListener(this, type, listener, true);
          };
          function onceWrapper() {
            if (!this.fired) {
              this.target.removeListener(this.type, this.wrapFn);
              this.fired = true;
              if (arguments.length === 0)
                return this.listener.call(this.target);
              return this.listener.apply(this.target, arguments);
            }
          }
          function _onceWrap(target, type, listener) {
            var state = { fired: false, wrapFn: void 0, target, type, listener };
            var wrapped = onceWrapper.bind(state);
            wrapped.listener = listener;
            state.wrapFn = wrapped;
            return wrapped;
          }
          EventEmitter.prototype.once = function once2(type, listener) {
            checkListener(listener);
            this.on(type, _onceWrap(this, type, listener));
            return this;
          };
          EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
            checkListener(listener);
            this.prependListener(type, _onceWrap(this, type, listener));
            return this;
          };
          EventEmitter.prototype.removeListener = function removeListener(type, listener) {
            var list, events, position, i, originalListener;
            checkListener(listener);
            events = this._events;
            if (events === void 0)
              return this;
            list = events[type];
            if (list === void 0)
              return this;
            if (list === listener || list.listener === listener) {
              if (--this._eventsCount === 0)
                this._events = /* @__PURE__ */ Object.create(null);
              else {
                delete events[type];
                if (events.removeListener)
                  this.emit("removeListener", type, list.listener || listener);
              }
            } else if (typeof list !== "function") {
              position = -1;
              for (i = list.length - 1; i >= 0; i--) {
                if (list[i] === listener || list[i].listener === listener) {
                  originalListener = list[i].listener;
                  position = i;
                  break;
                }
              }
              if (position < 0)
                return this;
              if (position === 0)
                list.shift();
              else {
                spliceOne(list, position);
              }
              if (list.length === 1)
                events[type] = list[0];
              if (events.removeListener !== void 0)
                this.emit("removeListener", type, originalListener || listener);
            }
            return this;
          };
          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
          EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
            var listeners, events, i;
            events = this._events;
            if (events === void 0)
              return this;
            if (events.removeListener === void 0) {
              if (arguments.length === 0) {
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
              } else if (events[type] !== void 0) {
                if (--this._eventsCount === 0)
                  this._events = /* @__PURE__ */ Object.create(null);
                else
                  delete events[type];
              }
              return this;
            }
            if (arguments.length === 0) {
              var keys = Object.keys(events);
              var key;
              for (i = 0; i < keys.length; ++i) {
                key = keys[i];
                if (key === "removeListener")
                  continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners("removeListener");
              this._events = /* @__PURE__ */ Object.create(null);
              this._eventsCount = 0;
              return this;
            }
            listeners = events[type];
            if (typeof listeners === "function") {
              this.removeListener(type, listeners);
            } else if (listeners !== void 0) {
              for (i = listeners.length - 1; i >= 0; i--) {
                this.removeListener(type, listeners[i]);
              }
            }
            return this;
          };
          function _listeners(target, type, unwrap) {
            var events = target._events;
            if (events === void 0)
              return [];
            var evlistener = events[type];
            if (evlistener === void 0)
              return [];
            if (typeof evlistener === "function")
              return unwrap ? [evlistener.listener || evlistener] : [evlistener];
            return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
          }
          EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true);
          };
          EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false);
          };
          EventEmitter.listenerCount = function(emitter, type) {
            if (typeof emitter.listenerCount === "function") {
              return emitter.listenerCount(type);
            } else {
              return listenerCount.call(emitter, type);
            }
          };
          EventEmitter.prototype.listenerCount = listenerCount;
          function listenerCount(type) {
            var events = this._events;
            if (events !== void 0) {
              var evlistener = events[type];
              if (typeof evlistener === "function") {
                return 1;
              } else if (evlistener !== void 0) {
                return evlistener.length;
              }
            }
            return 0;
          }
          EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
          };
          function arrayClone(arr, n) {
            var copy = new Array(n);
            for (var i = 0; i < n; ++i)
              copy[i] = arr[i];
            return copy;
          }
          function spliceOne(list, index) {
            for (; index + 1 < list.length; index++)
              list[index] = list[index + 1];
            list.pop();
          }
          function unwrapListeners(arr) {
            var ret = new Array(arr.length);
            for (var i = 0; i < ret.length; ++i) {
              ret[i] = arr[i].listener || arr[i];
            }
            return ret;
          }
          function once(emitter, name) {
            return new Promise(function(resolve, reject) {
              function errorListener(err) {
                emitter.removeListener(name, resolver);
                reject(err);
              }
              function resolver() {
                if (typeof emitter.removeListener === "function") {
                  emitter.removeListener("error", errorListener);
                }
                resolve([].slice.call(arguments));
              }
              ;
              eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
              if (name !== "error") {
                addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
              }
            });
          }
          function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
            if (typeof emitter.on === "function") {
              eventTargetAgnosticAddListener(emitter, "error", handler, flags);
            }
          }
          function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
            if (typeof emitter.on === "function") {
              if (flags.once) {
                emitter.once(name, listener);
              } else {
                emitter.on(name, listener);
              }
            } else if (typeof emitter.addEventListener === "function") {
              emitter.addEventListener(name, function wrapListener(arg) {
                if (flags.once) {
                  emitter.removeEventListener(name, wrapListener);
                }
                listener(arg);
              });
            } else {
              throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
            }
          }
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var nodes = __webpack_require__(3);
          var lib = __webpack_require__(0);
          var sym = 0;
          function gensym() {
            return "hole_" + sym++;
          }
          function mapCOW(arr, func) {
            var res = null;
            for (var i = 0; i < arr.length; i++) {
              var item = func(arr[i]);
              if (item !== arr[i]) {
                if (!res) {
                  res = arr.slice();
                }
                res[i] = item;
              }
            }
            return res || arr;
          }
          function walk(ast, func, depthFirst) {
            if (!(ast instanceof nodes.Node)) {
              return ast;
            }
            if (!depthFirst) {
              var astT = func(ast);
              if (astT && astT !== ast) {
                return astT;
              }
            }
            if (ast instanceof nodes.NodeList) {
              var children2 = mapCOW(ast.children, function(node) {
                return walk(node, func, depthFirst);
              });
              if (children2 !== ast.children) {
                ast = new nodes[ast.typename](ast.lineno, ast.colno, children2);
              }
            } else if (ast instanceof nodes.CallExtension) {
              var args = walk(ast.args, func, depthFirst);
              var contentArgs = mapCOW(ast.contentArgs, function(node) {
                return walk(node, func, depthFirst);
              });
              if (args !== ast.args || contentArgs !== ast.contentArgs) {
                ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
              }
            } else {
              var props = ast.fields.map(function(field) {
                return ast[field];
              });
              var propsT = mapCOW(props, function(prop) {
                return walk(prop, func, depthFirst);
              });
              if (propsT !== props) {
                ast = new nodes[ast.typename](ast.lineno, ast.colno);
                propsT.forEach(function(prop, i) {
                  ast[ast.fields[i]] = prop;
                });
              }
            }
            return depthFirst ? func(ast) || ast : ast;
          }
          function depthWalk(ast, func) {
            return walk(ast, func, true);
          }
          function _liftFilters(node, asyncFilters, prop) {
            var children2 = [];
            var walked = depthWalk(prop ? node[prop] : node, function(descNode) {
              var symbol;
              if (descNode instanceof nodes.Block) {
                return descNode;
              } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
                symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
                children2.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
              }
              return symbol;
            });
            if (prop) {
              node[prop] = walked;
            } else {
              node = walked;
            }
            if (children2.length) {
              children2.push(node);
              return new nodes.NodeList(node.lineno, node.colno, children2);
            } else {
              return node;
            }
          }
          function liftFilters(ast, asyncFilters) {
            return depthWalk(ast, function(node) {
              if (node instanceof nodes.Output) {
                return _liftFilters(node, asyncFilters);
              } else if (node instanceof nodes.Set) {
                return _liftFilters(node, asyncFilters, "value");
              } else if (node instanceof nodes.For) {
                return _liftFilters(node, asyncFilters, "arr");
              } else if (node instanceof nodes.If) {
                return _liftFilters(node, asyncFilters, "cond");
              } else if (node instanceof nodes.CallExtension) {
                return _liftFilters(node, asyncFilters, "args");
              } else {
                return void 0;
              }
            });
          }
          function liftSuper(ast) {
            return walk(ast, function(blockNode) {
              if (!(blockNode instanceof nodes.Block)) {
                return;
              }
              var hasSuper = false;
              var symbol = gensym();
              blockNode.body = walk(blockNode.body, function(node) {
                if (node instanceof nodes.FunCall && node.name.value === "super") {
                  hasSuper = true;
                  return new nodes.Symbol(node.lineno, node.colno, symbol);
                }
              });
              if (hasSuper) {
                blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
              }
            });
          }
          function convertStatements(ast) {
            return depthWalk(ast, function(node) {
              if (!(node instanceof nodes.If) && !(node instanceof nodes.For)) {
                return void 0;
              }
              var async = false;
              walk(node, function(child) {
                if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
                  async = true;
                  return child;
                }
                return void 0;
              });
              if (async) {
                if (node instanceof nodes.If) {
                  return new nodes.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
                } else if (node instanceof nodes.For && !(node instanceof nodes.AsyncAll)) {
                  return new nodes.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
                }
              }
              return void 0;
            });
          }
          function cps(ast, asyncFilters) {
            return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
          }
          function transform(ast, asyncFilters) {
            return cps(ast, asyncFilters || []);
          }
          module3.exports = {
            transform
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var lib = __webpack_require__(0);
          var r = __webpack_require__(2);
          var exports2 = module3.exports = {};
          function normalize(value, defaultValue) {
            if (value === null || value === void 0 || value === false) {
              return defaultValue;
            }
            return value;
          }
          exports2.abs = Math.abs;
          function isNaN2(num) {
            return num !== num;
          }
          function batch(arr, linecount, fillWith) {
            var i;
            var res = [];
            var tmp = [];
            for (i = 0; i < arr.length; i++) {
              if (i % linecount === 0 && tmp.length) {
                res.push(tmp);
                tmp = [];
              }
              tmp.push(arr[i]);
            }
            if (tmp.length) {
              if (fillWith) {
                for (i = tmp.length; i < linecount; i++) {
                  tmp.push(fillWith);
                }
              }
              res.push(tmp);
            }
            return res;
          }
          exports2.batch = batch;
          function capitalize(str) {
            str = normalize(str, "");
            var ret = str.toLowerCase();
            return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
          }
          exports2.capitalize = capitalize;
          function center(str, width) {
            str = normalize(str, "");
            width = width || 80;
            if (str.length >= width) {
              return str;
            }
            var spaces = width - str.length;
            var pre = lib.repeat(" ", spaces / 2 - spaces % 2);
            var post = lib.repeat(" ", spaces / 2);
            return r.copySafeness(str, pre + str + post);
          }
          exports2.center = center;
          function default_(val, def, bool) {
            if (bool) {
              return val || def;
            } else {
              return val !== void 0 ? val : def;
            }
          }
          exports2["default"] = default_;
          function dictsort(val, caseSensitive, by) {
            if (!lib.isObject(val)) {
              throw new lib.TemplateError("dictsort filter: val must be an object");
            }
            var array = [];
            for (var k in val) {
              array.push([k, val[k]]);
            }
            var si;
            if (by === void 0 || by === "key") {
              si = 0;
            } else if (by === "value") {
              si = 1;
            } else {
              throw new lib.TemplateError("dictsort filter: You can only sort by either key or value");
            }
            array.sort(function(t1, t2) {
              var a = t1[si];
              var b = t2[si];
              if (!caseSensitive) {
                if (lib.isString(a)) {
                  a = a.toUpperCase();
                }
                if (lib.isString(b)) {
                  b = b.toUpperCase();
                }
              }
              return a > b ? 1 : a === b ? 0 : -1;
            });
            return array;
          }
          exports2.dictsort = dictsort;
          function dump(obj, spaces) {
            return JSON.stringify(obj, null, spaces);
          }
          exports2.dump = dump;
          function escape(str) {
            if (str instanceof r.SafeString) {
              return str;
            }
            str = str === null || str === void 0 ? "" : str;
            return r.markSafe(lib.escape(str.toString()));
          }
          exports2.escape = escape;
          function safe(str) {
            if (str instanceof r.SafeString) {
              return str;
            }
            str = str === null || str === void 0 ? "" : str;
            return r.markSafe(str.toString());
          }
          exports2.safe = safe;
          function first(arr) {
            return arr[0];
          }
          exports2.first = first;
          function forceescape(str) {
            str = str === null || str === void 0 ? "" : str;
            return r.markSafe(lib.escape(str.toString()));
          }
          exports2.forceescape = forceescape;
          function groupby(arr, attr2) {
            return lib.groupBy(arr, attr2, this.env.opts.throwOnUndefined);
          }
          exports2.groupby = groupby;
          function indent(str, width, indentfirst) {
            str = normalize(str, "");
            if (str === "") {
              return "";
            }
            width = width || 4;
            var lines = str.split("\n");
            var sp = lib.repeat(" ", width);
            var res = lines.map(function(l, i) {
              return i === 0 && !indentfirst ? l : "" + sp + l;
            }).join("\n");
            return r.copySafeness(str, res);
          }
          exports2.indent = indent;
          function join(arr, del, attr2) {
            del = del || "";
            if (attr2) {
              arr = lib.map(arr, function(v) {
                return v[attr2];
              });
            }
            return arr.join(del);
          }
          exports2.join = join;
          function last(arr) {
            return arr[arr.length - 1];
          }
          exports2.last = last;
          function lengthFilter(val) {
            var value = normalize(val, "");
            if (value !== void 0) {
              if (typeof Map === "function" && value instanceof Map || typeof Set === "function" && value instanceof Set) {
                return value.size;
              }
              if (lib.isObject(value) && !(value instanceof r.SafeString)) {
                return lib.keys(value).length;
              }
              return value.length;
            }
            return 0;
          }
          exports2.length = lengthFilter;
          function list(val) {
            if (lib.isString(val)) {
              return val.split("");
            } else if (lib.isObject(val)) {
              return lib._entries(val || {}).map(function(_ref) {
                var key = _ref[0], value = _ref[1];
                return {
                  key,
                  value
                };
              });
            } else if (lib.isArray(val)) {
              return val;
            } else {
              throw new lib.TemplateError("list filter: type not iterable");
            }
          }
          exports2.list = list;
          function lower(str) {
            str = normalize(str, "");
            return str.toLowerCase();
          }
          exports2.lower = lower;
          function nl2br(str) {
            if (str === null || str === void 0) {
              return "";
            }
            return r.copySafeness(str, str.replace(/\r\n|\n/g, "<br />\n"));
          }
          exports2.nl2br = nl2br;
          function random(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
          }
          exports2.random = random;
          function getSelectOrReject(expectedTestResult) {
            function filter(arr, testName, secondArg) {
              if (testName === void 0) {
                testName = "truthy";
              }
              var context = this;
              var test = context.env.getTest(testName);
              return lib.toArray(arr).filter(function examineTestResult(item) {
                return test.call(context, item, secondArg) === expectedTestResult;
              });
            }
            return filter;
          }
          exports2.reject = getSelectOrReject(false);
          function rejectattr(arr, attr2) {
            return arr.filter(function(item) {
              return !item[attr2];
            });
          }
          exports2.rejectattr = rejectattr;
          exports2.select = getSelectOrReject(true);
          function selectattr(arr, attr2) {
            return arr.filter(function(item) {
              return !!item[attr2];
            });
          }
          exports2.selectattr = selectattr;
          function replace(str, old, new_, maxCount) {
            var originalStr = str;
            if (old instanceof RegExp) {
              return str.replace(old, new_);
            }
            if (typeof maxCount === "undefined") {
              maxCount = -1;
            }
            var res = "";
            if (typeof old === "number") {
              old = "" + old;
            } else if (typeof old !== "string") {
              return str;
            }
            if (typeof str === "number") {
              str = "" + str;
            }
            if (typeof str !== "string" && !(str instanceof r.SafeString)) {
              return str;
            }
            if (old === "") {
              res = new_ + str.split("").join(new_) + new_;
              return r.copySafeness(str, res);
            }
            var nextIndex = str.indexOf(old);
            if (maxCount === 0 || nextIndex === -1) {
              return str;
            }
            var pos = 0;
            var count = 0;
            while (nextIndex > -1 && (maxCount === -1 || count < maxCount)) {
              res += str.substring(pos, nextIndex) + new_;
              pos = nextIndex + old.length;
              count++;
              nextIndex = str.indexOf(old, pos);
            }
            if (pos < str.length) {
              res += str.substring(pos);
            }
            return r.copySafeness(originalStr, res);
          }
          exports2.replace = replace;
          function reverse(val) {
            var arr;
            if (lib.isString(val)) {
              arr = list(val);
            } else {
              arr = lib.map(val, function(v) {
                return v;
              });
            }
            arr.reverse();
            if (lib.isString(val)) {
              return r.copySafeness(val, arr.join(""));
            }
            return arr;
          }
          exports2.reverse = reverse;
          function round(val, precision, method) {
            precision = precision || 0;
            var factor = Math.pow(10, precision);
            var rounder;
            if (method === "ceil") {
              rounder = Math.ceil;
            } else if (method === "floor") {
              rounder = Math.floor;
            } else {
              rounder = Math.round;
            }
            return rounder(val * factor) / factor;
          }
          exports2.round = round;
          function slice(arr, slices, fillWith) {
            var sliceLength = Math.floor(arr.length / slices);
            var extra = arr.length % slices;
            var res = [];
            var offset = 0;
            for (var i = 0; i < slices; i++) {
              var start = offset + i * sliceLength;
              if (i < extra) {
                offset++;
              }
              var end = offset + (i + 1) * sliceLength;
              var currSlice = arr.slice(start, end);
              if (fillWith && i >= extra) {
                currSlice.push(fillWith);
              }
              res.push(currSlice);
            }
            return res;
          }
          exports2.slice = slice;
          function sum(arr, attr2, start) {
            if (start === void 0) {
              start = 0;
            }
            if (attr2) {
              arr = lib.map(arr, function(v) {
                return v[attr2];
              });
            }
            return start + arr.reduce(function(a, b) {
              return a + b;
            }, 0);
          }
          exports2.sum = sum;
          exports2.sort = r.makeMacro(["value", "reverse", "case_sensitive", "attribute"], [], function sortFilter(arr, reversed, caseSens, attr2) {
            var _this = this;
            var array = lib.map(arr, function(v) {
              return v;
            });
            var getAttribute = lib.getAttrGetter(attr2);
            array.sort(function(a, b) {
              var x = attr2 ? getAttribute(a) : a;
              var y = attr2 ? getAttribute(b) : b;
              if (_this.env.opts.throwOnUndefined && attr2 && (x === void 0 || y === void 0)) {
                throw new TypeError('sort: attribute "' + attr2 + '" resolved to undefined');
              }
              if (!caseSens && lib.isString(x) && lib.isString(y)) {
                x = x.toLowerCase();
                y = y.toLowerCase();
              }
              if (x < y) {
                return reversed ? 1 : -1;
              } else if (x > y) {
                return reversed ? -1 : 1;
              } else {
                return 0;
              }
            });
            return array;
          });
          function string(obj) {
            return r.copySafeness(obj, obj);
          }
          exports2.string = string;
          function striptags(input, preserveLinebreaks) {
            input = normalize(input, "");
            var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
            var trimmedInput = trim(input.replace(tags, ""));
            var res = "";
            if (preserveLinebreaks) {
              res = trimmedInput.replace(/^ +| +$/gm, "").replace(/ +/g, " ").replace(/(\r\n)/g, "\n").replace(/\n\n\n+/g, "\n\n");
            } else {
              res = trimmedInput.replace(/\s+/gi, " ");
            }
            return r.copySafeness(input, res);
          }
          exports2.striptags = striptags;
          function title(str) {
            str = normalize(str, "");
            var words = str.split(" ").map(function(word) {
              return capitalize(word);
            });
            return r.copySafeness(str, words.join(" "));
          }
          exports2.title = title;
          function trim(str) {
            return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ""));
          }
          exports2.trim = trim;
          function truncate2(input, length, killwords, end) {
            var orig = input;
            input = normalize(input, "");
            length = length || 255;
            if (input.length <= length) {
              return input;
            }
            if (killwords) {
              input = input.substring(0, length);
            } else {
              var idx = input.lastIndexOf(" ", length);
              if (idx === -1) {
                idx = length;
              }
              input = input.substring(0, idx);
            }
            input += end !== void 0 && end !== null ? end : "...";
            return r.copySafeness(orig, input);
          }
          exports2.truncate = truncate2;
          function upper(str) {
            str = normalize(str, "");
            return str.toUpperCase();
          }
          exports2.upper = upper;
          function urlencode(obj) {
            var enc = encodeURIComponent;
            if (lib.isString(obj)) {
              return enc(obj);
            } else {
              var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
              return keyvals.map(function(_ref2) {
                var k = _ref2[0], v = _ref2[1];
                return enc(k) + "=" + enc(v);
              }).join("&");
            }
          }
          exports2.urlencode = urlencode;
          var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/;
          var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
          var httpHttpsRe = /^https?:\/\/.*$/;
          var wwwRe = /^www\./;
          var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;
          function urlize(str, length, nofollow) {
            if (isNaN2(length)) {
              length = Infinity;
            }
            var noFollowAttr = nofollow === true ? ' rel="nofollow"' : "";
            var words = str.split(/(\s+)/).filter(function(word) {
              return word && word.length;
            }).map(function(word) {
              var matches = word.match(puncRe);
              var possibleUrl = matches ? matches[1] : word;
              var shortUrl = possibleUrl.substr(0, length);
              if (httpHttpsRe.test(possibleUrl)) {
                return '<a href="' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
              }
              if (wwwRe.test(possibleUrl)) {
                return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
              }
              if (emailRe.test(possibleUrl)) {
                return '<a href="mailto:' + possibleUrl + '">' + possibleUrl + "</a>";
              }
              if (tldRe.test(possibleUrl)) {
                return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
              }
              return word;
            });
            return words.join("");
          }
          exports2.urlize = urlize;
          function wordcount(str) {
            str = normalize(str, "");
            var words = str ? str.match(/\w+/g) : null;
            return words ? words.length : null;
          }
          exports2.wordcount = wordcount;
          function float(val, def) {
            var res = parseFloat(val);
            return isNaN2(res) ? def : res;
          }
          exports2.float = float;
          var intFilter = r.makeMacro(["value", "default", "base"], [], function doInt(value, defaultValue, base) {
            if (base === void 0) {
              base = 10;
            }
            var res = parseInt(value, base);
            return isNaN2(res) ? defaultValue : res;
          });
          exports2.int = intFilter;
          exports2.d = exports2.default;
          exports2.e = exports2.escape;
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          var Loader = __webpack_require__(6);
          var PrecompiledLoader = /* @__PURE__ */ function(_Loader) {
            _inheritsLoose(PrecompiledLoader2, _Loader);
            function PrecompiledLoader2(compiledTemplates) {
              var _this;
              _this = _Loader.call(this) || this;
              _this.precompiled = compiledTemplates || {};
              return _this;
            }
            var _proto = PrecompiledLoader2.prototype;
            _proto.getSource = function getSource(name) {
              if (this.precompiled[name]) {
                return {
                  src: {
                    type: "code",
                    obj: this.precompiled[name]
                  },
                  path: name
                };
              }
              return null;
            };
            return PrecompiledLoader2;
          }(Loader);
          module3.exports = {
            PrecompiledLoader
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var SafeString = __webpack_require__(2).SafeString;
          function callable(value) {
            return typeof value === "function";
          }
          exports2.callable = callable;
          function defined(value) {
            return value !== void 0;
          }
          exports2.defined = defined;
          function divisibleby(one, two) {
            return one % two === 0;
          }
          exports2.divisibleby = divisibleby;
          function escaped(value) {
            return value instanceof SafeString;
          }
          exports2.escaped = escaped;
          function equalto(one, two) {
            return one === two;
          }
          exports2.equalto = equalto;
          exports2.eq = exports2.equalto;
          exports2.sameas = exports2.equalto;
          function even(value) {
            return value % 2 === 0;
          }
          exports2.even = even;
          function falsy(value) {
            return !value;
          }
          exports2.falsy = falsy;
          function ge(one, two) {
            return one >= two;
          }
          exports2.ge = ge;
          function greaterthan(one, two) {
            return one > two;
          }
          exports2.greaterthan = greaterthan;
          exports2.gt = exports2.greaterthan;
          function le(one, two) {
            return one <= two;
          }
          exports2.le = le;
          function lessthan(one, two) {
            return one < two;
          }
          exports2.lessthan = lessthan;
          exports2.lt = exports2.lessthan;
          function lower(value) {
            return value.toLowerCase() === value;
          }
          exports2.lower = lower;
          function ne(one, two) {
            return one !== two;
          }
          exports2.ne = ne;
          function nullTest(value) {
            return value === null;
          }
          exports2.null = nullTest;
          function number(value) {
            return typeof value === "number";
          }
          exports2.number = number;
          function odd(value) {
            return value % 2 === 1;
          }
          exports2.odd = odd;
          function string(value) {
            return typeof value === "string";
          }
          exports2.string = string;
          function truthy(value) {
            return !!value;
          }
          exports2.truthy = truthy;
          function undefinedTest(value) {
            return value === void 0;
          }
          exports2.undefined = undefinedTest;
          function upper(value) {
            return value.toUpperCase() === value;
          }
          exports2.upper = upper;
          function iterable(value) {
            if (typeof Symbol !== "undefined") {
              return !!value[Symbol.iterator];
            } else {
              return Array.isArray(value) || typeof value === "string";
            }
          }
          exports2.iterable = iterable;
          function mapping(value) {
            var bool = value !== null && value !== void 0 && typeof value === "object" && !Array.isArray(value);
            if (Set) {
              return bool && !(value instanceof Set);
            } else {
              return bool;
            }
          }
          exports2.mapping = mapping;
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          function _cycler(items) {
            var index = -1;
            return {
              current: null,
              reset: function reset() {
                index = -1;
                this.current = null;
              },
              next: function next() {
                index++;
                if (index >= items.length) {
                  index = 0;
                }
                this.current = items[index];
                return this.current;
              }
            };
          }
          function _joiner(sep) {
            sep = sep || ",";
            var first = true;
            return function() {
              var val = first ? "" : sep;
              first = false;
              return val;
            };
          }
          function globals2() {
            return {
              range: function range(start, stop, step) {
                if (typeof stop === "undefined") {
                  stop = start;
                  start = 0;
                  step = 1;
                } else if (!step) {
                  step = 1;
                }
                var arr = [];
                if (step > 0) {
                  for (var i = start; i < stop; i += step) {
                    arr.push(i);
                  }
                } else {
                  for (var _i = start; _i > stop; _i += step) {
                    arr.push(_i);
                  }
                }
                return arr;
              },
              cycler: function cycler() {
                return _cycler(Array.prototype.slice.call(arguments));
              },
              joiner: function joiner(sep) {
                return _joiner(sep);
              }
            };
          }
          module3.exports = globals2;
        },
        function(module3, exports2, __webpack_require__) {
          var path = __webpack_require__(4);
          module3.exports = function express(env, app2) {
            function NunjucksView(name, opts) {
              this.name = name;
              this.path = name;
              this.defaultEngine = opts.defaultEngine;
              this.ext = path.extname(name);
              if (!this.ext && !this.defaultEngine) {
                throw new Error("No default engine was specified and no extension was provided.");
              }
              if (!this.ext) {
                this.name += this.ext = (this.defaultEngine[0] !== "." ? "." : "") + this.defaultEngine;
              }
            }
            NunjucksView.prototype.render = function render(opts, cb) {
              env.render(this.name, opts, cb);
            };
            app2.set("view", NunjucksView);
            app2.set("nunjucksEnv", env);
            return env;
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var fs = __webpack_require__(4);
          var path = __webpack_require__(4);
          var _require = __webpack_require__(0), _prettifyError = _require._prettifyError;
          var compiler = __webpack_require__(5);
          var _require2 = __webpack_require__(7), Environment = _require2.Environment;
          var precompileGlobal = __webpack_require__(24);
          function match(filename, patterns) {
            if (!Array.isArray(patterns)) {
              return false;
            }
            return patterns.some(function(pattern) {
              return filename.match(pattern);
            });
          }
          function precompileString(str, opts) {
            opts = opts || {};
            opts.isString = true;
            var env = opts.env || new Environment([]);
            var wrapper = opts.wrapper || precompileGlobal;
            if (!opts.name) {
              throw new Error('the "name" option is required when compiling a string');
            }
            return wrapper([_precompile(str, opts.name, env)], opts);
          }
          function precompile(input, opts) {
            opts = opts || {};
            var env = opts.env || new Environment([]);
            var wrapper = opts.wrapper || precompileGlobal;
            if (opts.isString) {
              return precompileString(input, opts);
            }
            var pathStats = fs.existsSync(input) && fs.statSync(input);
            var precompiled = [];
            var templates = [];
            function addTemplates(dir) {
              fs.readdirSync(dir).forEach(function(file) {
                var filepath = path.join(dir, file);
                var subpath = filepath.substr(path.join(input, "/").length);
                var stat = fs.statSync(filepath);
                if (stat && stat.isDirectory()) {
                  subpath += "/";
                  if (!match(subpath, opts.exclude)) {
                    addTemplates(filepath);
                  }
                } else if (match(subpath, opts.include)) {
                  templates.push(filepath);
                }
              });
            }
            if (pathStats.isFile()) {
              precompiled.push(_precompile(fs.readFileSync(input, "utf-8"), opts.name || input, env));
            } else if (pathStats.isDirectory()) {
              addTemplates(input);
              for (var i = 0; i < templates.length; i++) {
                var name = templates[i].replace(path.join(input, "/"), "");
                try {
                  precompiled.push(_precompile(fs.readFileSync(templates[i], "utf-8"), name, env));
                } catch (e) {
                  if (opts.force) {
                    console.error(e);
                  } else {
                    throw e;
                  }
                }
              }
            }
            return wrapper(precompiled, opts);
          }
          function _precompile(str, name, env) {
            env = env || new Environment([]);
            var asyncFilters = env.asyncFilters;
            var extensions = env.extensionsList;
            var template;
            name = name.replace(/\\/g, "/");
            try {
              template = compiler.compile(str, asyncFilters, extensions, name, env.opts);
            } catch (err) {
              throw _prettifyError(name, false, err);
            }
            return {
              name,
              template
            };
          }
          module3.exports = {
            precompile,
            precompileString
          };
        },
        function(module3, exports2, __webpack_require__) {
          "use strict";
          function precompileGlobal(templates, opts) {
            var out = "";
            opts = opts || {};
            for (var i = 0; i < templates.length; i++) {
              var name = JSON.stringify(templates[i].name);
              var template = templates[i].template;
              out += "(function() {(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})[" + name + "] = (function() {\n" + template + "\n})();\n";
              if (opts.asFunction) {
                out += "return function(ctx, cb) { return nunjucks.render(" + name + ", ctx, cb); }\n";
              }
              out += "})();\n";
            }
            return out;
          }
          module3.exports = precompileGlobal;
        },
        function(module3, exports2, __webpack_require__) {
          function installCompat() {
            "use strict";
            var runtime = this.runtime;
            var lib = this.lib;
            var Compiler = this.compiler.Compiler;
            var Parser = this.parser.Parser;
            var nodes = this.nodes;
            var lexer = this.lexer;
            var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
            var orig_memberLookup = runtime.memberLookup;
            var orig_Compiler_assertType;
            var orig_Parser_parseAggregate;
            if (Compiler) {
              orig_Compiler_assertType = Compiler.prototype.assertType;
            }
            if (Parser) {
              orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
            }
            function uninstall() {
              runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
              runtime.memberLookup = orig_memberLookup;
              if (Compiler) {
                Compiler.prototype.assertType = orig_Compiler_assertType;
              }
              if (Parser) {
                Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
              }
            }
            runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
              var val = orig_contextOrFrameLookup.apply(this, arguments);
              if (val !== void 0) {
                return val;
              }
              switch (key) {
                case "True":
                  return true;
                case "False":
                  return false;
                case "None":
                  return null;
                default:
                  return void 0;
              }
            };
            function getTokensState(tokens) {
              return {
                index: tokens.index,
                lineno: tokens.lineno,
                colno: tokens.colno
              };
            }
            if (nodes && Compiler && Parser) {
              var Slice = nodes.Node.extend("Slice", {
                fields: ["start", "stop", "step"],
                init: function init2(lineno, colno, start, stop, step) {
                  start = start || new nodes.Literal(lineno, colno, null);
                  stop = stop || new nodes.Literal(lineno, colno, null);
                  step = step || new nodes.Literal(lineno, colno, 1);
                  this.parent(lineno, colno, start, stop, step);
                }
              });
              Compiler.prototype.assertType = function assertType(node) {
                if (node instanceof Slice) {
                  return;
                }
                orig_Compiler_assertType.apply(this, arguments);
              };
              Compiler.prototype.compileSlice = function compileSlice(node, frame) {
                this._emit("(");
                this._compileExpression(node.start, frame);
                this._emit("),(");
                this._compileExpression(node.stop, frame);
                this._emit("),(");
                this._compileExpression(node.step, frame);
                this._emit(")");
              };
              Parser.prototype.parseAggregate = function parseAggregate() {
                var _this = this;
                var origState = getTokensState(this.tokens);
                origState.colno--;
                origState.index--;
                try {
                  return orig_Parser_parseAggregate.apply(this);
                } catch (e) {
                  var errState = getTokensState(this.tokens);
                  var rethrow = function rethrow2() {
                    lib._assign(_this.tokens, errState);
                    return e;
                  };
                  lib._assign(this.tokens, origState);
                  this.peeked = false;
                  var tok = this.peekToken();
                  if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
                    throw rethrow();
                  } else {
                    this.nextToken();
                  }
                  var node = new Slice(tok.lineno, tok.colno);
                  var isSlice = false;
                  for (var i = 0; i <= node.fields.length; i++) {
                    if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
                      break;
                    }
                    if (i === node.fields.length) {
                      if (isSlice) {
                        this.fail("parseSlice: too many slice components", tok.lineno, tok.colno);
                      } else {
                        break;
                      }
                    }
                    if (this.skip(lexer.TOKEN_COLON)) {
                      isSlice = true;
                    } else {
                      var field = node.fields[i];
                      node[field] = this.parseExpression();
                      isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
                    }
                  }
                  if (!isSlice) {
                    throw rethrow();
                  }
                  return new nodes.Array(tok.lineno, tok.colno, [node]);
                }
              };
            }
            function sliceLookup(obj, start, stop, step) {
              obj = obj || [];
              if (start === null) {
                start = step < 0 ? obj.length - 1 : 0;
              }
              if (stop === null) {
                stop = step < 0 ? -1 : obj.length;
              } else if (stop < 0) {
                stop += obj.length;
              }
              if (start < 0) {
                start += obj.length;
              }
              var results = [];
              for (var i = start; ; i += step) {
                if (i < 0 || i > obj.length) {
                  break;
                }
                if (step > 0 && i >= stop) {
                  break;
                }
                if (step < 0 && i <= stop) {
                  break;
                }
                results.push(runtime.memberLookup(obj, i));
              }
              return results;
            }
            function hasOwnProp(obj, key) {
              return Object.prototype.hasOwnProperty.call(obj, key);
            }
            var ARRAY_MEMBERS = {
              pop: function pop(index) {
                if (index === void 0) {
                  return this.pop();
                }
                if (index >= this.length || index < 0) {
                  throw new Error("KeyError");
                }
                return this.splice(index, 1);
              },
              append: function append2(element2) {
                return this.push(element2);
              },
              remove: function remove(element2) {
                for (var i = 0; i < this.length; i++) {
                  if (this[i] === element2) {
                    return this.splice(i, 1);
                  }
                }
                throw new Error("ValueError");
              },
              count: function count(element2) {
                var count2 = 0;
                for (var i = 0; i < this.length; i++) {
                  if (this[i] === element2) {
                    count2++;
                  }
                }
                return count2;
              },
              index: function index(element2) {
                var i;
                if ((i = this.indexOf(element2)) === -1) {
                  throw new Error("ValueError");
                }
                return i;
              },
              find: function find(element2) {
                return this.indexOf(element2);
              },
              insert: function insert2(index, elem) {
                return this.splice(index, 0, elem);
              }
            };
            var OBJECT_MEMBERS = {
              items: function items() {
                return lib._entries(this);
              },
              values: function values() {
                return lib._values(this);
              },
              keys: function keys() {
                return lib.keys(this);
              },
              get: function get(key, def) {
                var output = this[key];
                if (output === void 0) {
                  output = def;
                }
                return output;
              },
              has_key: function has_key(key) {
                return hasOwnProp(this, key);
              },
              pop: function pop(key, def) {
                var output = this[key];
                if (output === void 0 && def !== void 0) {
                  output = def;
                } else if (output === void 0) {
                  throw new Error("KeyError");
                } else {
                  delete this[key];
                }
                return output;
              },
              popitem: function popitem() {
                var keys = lib.keys(this);
                if (!keys.length) {
                  throw new Error("KeyError");
                }
                var k = keys[0];
                var val = this[k];
                delete this[k];
                return [k, val];
              },
              setdefault: function setdefault(key, def) {
                if (def === void 0) {
                  def = null;
                }
                if (!(key in this)) {
                  this[key] = def;
                }
                return this[key];
              },
              update: function update2(kwargs) {
                lib._assign(this, kwargs);
                return null;
              }
            };
            OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
            OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
            OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;
            runtime.memberLookup = function memberLookup(obj, val, autoescape) {
              if (arguments.length === 4) {
                return sliceLookup.apply(this, arguments);
              }
              obj = obj || {};
              if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
                return ARRAY_MEMBERS[val].bind(obj);
              }
              if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
                return OBJECT_MEMBERS[val].bind(obj);
              }
              return orig_memberLookup.apply(this, arguments);
            };
            return uninstall;
          }
          module3.exports = installCompat;
        }
      ]);
    });
  }
});

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment2(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment2 || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(func.apply(this, arguments), token2);
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }));
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
            this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        doy: 6
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
            this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
            this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("Locale " + key + " not found. Did you forget to load it?");
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
      });
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
          return obj && parseInt(obj, 10);
        });
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment2(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment2(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      });
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(this, createDuration(input - offset2, "m"), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(output || this.localeData().calendar(format2, this, createLocal(now2)));
      }
      function clone() {
        return new Moment2(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      });
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;
          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      });
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment2.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
      proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
      proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
      proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
      proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
      hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        w: null,
        M: 11
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "GGGG-[W]WW",
        MONTH: "YYYY-MM"
      };
      return hooks;
    });
  }
});

// node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS({
  "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports, module2) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function truncate2(getLength, string, byteLength) {
      if (typeof string !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i = 0; i < charLength; i += 1) {
        codePoint = string.charCodeAt(i);
        segment = string[i];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {
          i += 1;
          segment += string[i];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength) {
          return string.slice(0, i + 1);
        } else if (curByteLength > byteLength) {
          return string.slice(0, i - segment.length + 1);
        }
      }
      return string;
    };
  }
});

// node_modules/utf8-byte-length/browser.js
var require_browser = __commonJS({
  "node_modules/utf8-byte-length/browser.js"(exports, module2) {
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function getByteLength(string) {
      if (typeof string !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string.length;
      var byteLength = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i = 0; i < charLength; i++) {
        codePoint = string.charCodeAt(i);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength += 1;
          } else {
            byteLength += 3;
          }
        } else if (codePoint <= 127) {
          byteLength += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength;
    };
  }
});

// node_modules/truncate-utf8-bytes/browser.js
var require_browser2 = __commonJS({
  "node_modules/truncate-utf8-bytes/browser.js"(exports, module2) {
    "use strict";
    var truncate2 = require_truncate();
    var getLength = require_browser();
    module2.exports = truncate2.bind(null, getLength);
  }
});

// node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS({
  "node_modules/sanitize-filename/index.js"(exports, module2) {
    "use strict";
    var truncate2 = require_browser2();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize2(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate2(sanitized, 255);
    }
    module2.exports = function(input, options) {
      var replacement = options && options.replacement || "";
      var output = sanitize2(input, replacement);
      if (replacement === "") {
        return output;
      }
      return sanitize2(output, "");
    };
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    var kindOf = function(cache) {
      return function(thing) {
        var str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter) {
      var props;
      var i;
      var prop;
      var merged = {};
      destObj = destObj || {};
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if (!merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position) {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      var lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(thing) {
      if (!thing)
        return null;
      var i = thing.length;
      if (isUndefined(i))
        return null;
      var arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    }
    var isTypedArray = function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray,
      isFileList
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/AxiosError.js
var require_AxiosError = __commonJS({
  "node_modules/axios/lib/core/AxiosError.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function AxiosError2(message, code, config, request, response) {
      Error.call(this);
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils.inherits(AxiosError2, Error, {
      toJSON: function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError2.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED"
    ].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError2, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError2.from = function(error, code, config, request, response, customProps) {
      var axiosError = Object.create(prototype);
      utils.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      });
      AxiosError2.call(axiosError, error.message, code, config, request, response);
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    module2.exports = AxiosError2;
  }
});

// node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/axios/lib/defaults/transitional.js"(exports, module2) {
    "use strict";
    module2.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/axios/lib/helpers/toFormData.js
var require_toFormData = __commonJS({
  "node_modules/axios/lib/helpers/toFormData.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    function toFormData(obj, formData) {
      formData = formData || new FormData();
      var stack = [];
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function build(data, parentKey) {
        if (utils.isPlainObject(data) || utils.isArray(data)) {
          if (stack.indexOf(data) !== -1) {
            throw Error("Circular reference detected in " + parentKey);
          }
          stack.push(data);
          utils.forEach(data, function each(value, key) {
            if (utils.isUndefined(value))
              return;
            var fullKey = parentKey ? parentKey + "." + key : key;
            var arr;
            if (value && !parentKey && typeof value === "object") {
              if (utils.endsWith(key, "{}")) {
                value = JSON.stringify(value);
              } else if (utils.endsWith(key, "[]") && (arr = utils.toArray(value))) {
                arr.forEach(function(el) {
                  !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
                });
                return;
              }
            }
            build(value, fullKey);
          });
          stack.pop();
        } else {
          formData.append(parentKey, convertValue(data));
        }
      }
      build(obj);
      return formData;
    }
    module2.exports = toFormData;
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module2) {
    "use strict";
    var AxiosError2 = require_AxiosError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError2("Request failed with status code " + response.status, [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/axios/lib/cancel/CanceledError.js
var require_CanceledError = __commonJS({
  "node_modules/axios/lib/cancel/CanceledError.js"(exports, module2) {
    "use strict";
    var AxiosError2 = require_AxiosError();
    var utils = require_utils();
    function CanceledError(message) {
      AxiosError2.call(this, message == null ? "canceled" : message, AxiosError2.ERR_CANCELED);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError2, {
      __CANCEL__: true
    });
    module2.exports = CanceledError;
  }
});

// node_modules/axios/lib/helpers/parseProtocol.js
var require_parseProtocol = __commonJS({
  "node_modules/axios/lib/helpers/parseProtocol.js"(exports, module2) {
    "use strict";
    module2.exports = function parseProtocol(url) {
      var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    };
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var transitionalDefaults = require_transitional();
    var AxiosError2 = require_AxiosError();
    var CanceledError = require_CanceledError();
    var parseProtocol = require_parseProtocol();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError2("Request aborted", AxiosError2.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError2("Network Error", AxiosError2.ERR_NETWORK, config, request, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError2(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError2.ETIMEDOUT : AxiosError2.ECONNABORTED, config, request));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        var protocol = parseProtocol(fullPath);
        if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
          reject(new AxiosError2("Unsupported protocol " + protocol + ":", AxiosError2.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/helpers/null.js
var require_null = __commonJS({
  "node_modules/axios/lib/helpers/null.js"(exports, module2) {
    module2.exports = null;
  }
});

// node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults/index.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var AxiosError2 = require_AxiosError();
    var transitionalDefaults = require_transitional();
    var toFormData = require_toFormData();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        var isObjectPayload = utils.isObject(data);
        var contentType = headers && headers["Content-Type"];
        var isFileList;
        if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === "multipart/form-data") {
          var _FormData = this.env && this.env.FormData;
          return toFormData(isFileList ? { "files[]": data } : data, _FormData && new _FormData());
        } else if (isObjectPayload || contentType === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError2.from(e, AxiosError2.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: require_null()
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var CanceledError = require_CanceledError();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
      config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config.headers[method];
      });
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module2) {
    module2.exports = {
      "version": "0.27.2"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module2) {
    "use strict";
    var VERSION2 = require_data().version;
    var AxiosError2 = require_AxiosError();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION2 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new AxiosError2(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), AxiosError2.ERR_DEPRECATED);
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError2("options must be an object", AxiosError2.ERR_BAD_OPTION_VALUE);
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError2("option " + opt + " must be " + result, AxiosError2.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError2("Unknown option " + opt, AxiosError2.ERR_BAD_OPTION);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var buildFullPath = require_buildFullPath();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      var fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    module2.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module2) {
    "use strict";
    var CanceledError = require_CanceledError();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module2) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance3 = bind(Axios.prototype.request, context);
      utils.extend(instance3, Axios.prototype, context);
      utils.extend(instance3, context);
      instance3.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance3;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.CanceledError = require_CanceledError();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.toFormData = require_toFormData();
    axios2.AxiosError = require_AxiosError();
    axios2.Cancel = axios2.CanceledError;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module2.exports = axios2;
    module2.exports.default = axios2;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module2) {
    module2.exports = require_axios();
  }
});

// node_modules/is-retry-allowed/index.js
var require_is_retry_allowed = __commonJS({
  "node_modules/is-retry-allowed/index.js"(exports, module2) {
    "use strict";
    var denyList = /* @__PURE__ */ new Set([
      "ENOTFOUND",
      "ENETUNREACH",
      "UNABLE_TO_GET_ISSUER_CERT",
      "UNABLE_TO_GET_CRL",
      "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
      "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
      "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
      "CERT_SIGNATURE_FAILURE",
      "CRL_SIGNATURE_FAILURE",
      "CERT_NOT_YET_VALID",
      "CERT_HAS_EXPIRED",
      "CRL_NOT_YET_VALID",
      "CRL_HAS_EXPIRED",
      "ERROR_IN_CERT_NOT_BEFORE_FIELD",
      "ERROR_IN_CERT_NOT_AFTER_FIELD",
      "ERROR_IN_CRL_LAST_UPDATE_FIELD",
      "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
      "OUT_OF_MEM",
      "DEPTH_ZERO_SELF_SIGNED_CERT",
      "SELF_SIGNED_CERT_IN_CHAIN",
      "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
      "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
      "CERT_CHAIN_TOO_LONG",
      "CERT_REVOKED",
      "INVALID_CA",
      "PATH_LENGTH_EXCEEDED",
      "INVALID_PURPOSE",
      "CERT_UNTRUSTED",
      "CERT_REJECTED",
      "HOSTNAME_MISMATCH"
    ]);
    module2.exports = (error) => !denyList.has(error && error.code);
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module2) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module2.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module2) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module2) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module2) {
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module2) {
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module2) {
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module2) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module2) {
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module2) {
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module2) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert2(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert2(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module2) {
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module2) {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module2) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module2) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RaindropPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/settings.ts
var import_obsidian4 = require("obsidian");

// src/assets/defaultMetadataTemplate.njk
var defaultMetadataTemplate_default = "{% if link %}link: {{link}}{% endif %}\n{% if tags|length %}tags: {%for tag in tags %}\n- {{tag}}{% endfor %}{% endif %}\n";

// src/templates/templateInstructions.html
var templateInstructions_default = 'Template (<a href="https://mozilla.github.io/nunjucks/">Nunjucks</a>) for\nrendering every synced Raindrop.io highlights & annotations.\n\n<p>\n  <b>Available variables to use</b>\n</p>\n\nMetadata\n<ul>\n  <li><span class="u-pop">{{now}}</span> (Moment) - Present time</li>\n</ul>\n\nArticle Metadata\n<ul>\n  <li><span class="u-pop">{{is_new_article}}</span> (bool) - New file indicator</li>\n  <li><span class="u-pop">{{id}}</span> (number) - Article identifier</li>\n  <li><span class="u-pop">{{title}}</span> (string) - Title</li>\n  <li><span class="u-pop">{{excerpt}}</span> (string) - Article excerpt</li>\n  <li><span class="u-pop">{{note}}</span> (string) - Article note</li>\n  <li><span class="u-pop">{{link}}</span> (string) - Link to source</li>\n  <li><span class="u-pop">{{highlights}}</span> (Highlight[]) - List of your Highlights (Detail attributes refer to the following <span class="u-pop">Highlight</span> section)</li>\n  <li><span class="u-pop">{{collection}}</span> (Collection) - Collection data (Detail attributes refer to the following <span class="u-pop">Collection</span> section</li>\n  <li><span class="u-pop">{{creator}}</span> (Creator) - Creator data (Detail attributes refer to the following <span class="u-pop">Creator</span> section</li>\n  <li><span class="u-pop">{{tags}}</span> (string) - List of tag</li>\n  <li><span class="u-pop">{{cover}}</span> (string) - Article cover</li>\n  <li><span class="u-pop">{{created}}</span> (Moment) - Created on</li>\n  <li><span class="u-pop">{{type}}</span> (string) - Article type</li>\n  <li><span class="u-pop">{{important}}</span> (bool) - Favorite article</li>\n</ul>\n\nCreator\n<ul>\n  <li><span class="u-pop">{{name}}</span> (string) - Creator name</li>\n  <li><span class="u-pop">{{id}}</span> (number) - Creator id</li>\n</ul>\n\nCollection\n<ul>\n  <li><span class="u-pop">{{title}}</span> (string) - Collection title</li>\n</ul>\n\nHighlight\n<ul>\n  <li><span class="u-pop">{{id}}</span> (string) - Highlight identifier</li>\n  <li><span class="u-pop">{{text}}</span> (string) - Text</li>\n  <li><span class="u-pop">{{color}}</span> (string) - Highlight color</li>\n  <li><span class="u-pop">{{created}}</span> (Moment) - Created on</li>\n  <li><span class="u-pop">{{lastUpdate}}</span> (Moment) - Updated on</li>\n  <li><span class="u-pop">{{note}}</span> (string) - Annotation</li>\n</ul>\n\nFilter\n<ul>\n  <li><span class="u-pop">date(format: string)</span> Convert Moment object to string - example: <code>{{ now | date("YYYY/MM/DD") }}</code>. For more syntax, refer to <a href="https://momentjs.com/docs/#/displaying/format/">format reference</a>.</li>\n</ul>\n';

// src/templates/metadataTemplateInstructions.html
var metadataTemplateInstructions_default = 'Metadata template (<a href="https://mozilla.github.io/nunjucks/">Nunjucks</a>) for\nrendering every synced Raindrop.io highlights & annotations.\n\n<p>\n	Some notes:\n</p>\n<ul>\n	<li>The rendered result is placed in the front matter of the generated post.</li>\n	<li>If the rendered result does not follow the YAML syntax, the plugin will reject the update.</li>\n	<li><code>raindrop_id</code> and <code>raindrop_highlights</code> properties are transparently added by the plugin.</li>\n	<li>Available variables to use are the same as the previous template.</li>\n</ul>\n';

// src/templates/filenameTemplateInstructions.html
var filenameTemplateInstructions_default = 'Filename template (<a href="https://mozilla.github.io/nunjucks/">Nunjucks</a>) for\ncreating synced Raindrop.io highlights & annotations.\n\n<p>\n	Some notes:\n</p>\n<ul>\n	<li>The rendered result is used as the filename for the bookmark.</li>\n	<li>This template is only used when creating the new file.</li>\n	<li>The rendered result is sanitized and truncated to 255 bytes.</li>\n	<li>The plugin will reject the invalid template.</li>\n	<li>If the file already exists in the vault, the auto generated suffix will be appended to the rendered result and used as the filename.</li>\n	<li>Available variables to use are the same as the previous template.</li>\n</ul>\n';

// src/templates/collectionGroupsInstructions.html
var collectionGroupsInstructions_default = 'Add group name to the prefix of collection. See <a href="https://help.raindrop.io/collections/#groups">https://help.raindrop.io/collections/#groups</a> for more details about collection groups.\n';

// src/templates/appendModeInstructions.html
var appendModeInstructions_default = '<div>\n	<span class="u-pop">Dangerous Option!<span>\n</div>\n<ul>\n	<li>\n		On: The new highlights will be appended to the end of the existing file, but the old metadata can not be updated in place.\n	</li>\n	<li>\n		Off: The synced files will always be kept in the latest states of the Raindrop articles, but this will lose the flexiblity to add/modify the synced files. (i.e. the old file content will be overwritten!)\n	</li>\n</ul>\n';

// src/templates/autoescapingInstructions.html
var autoescapingInstructions_default = `If this option is turned on, Nunjucks will <a href="https://mozilla.github.io/nunjucks/templating.html#autoescaping">autoescape</a> all output during the template rendering process. To manually mark output as safe, use the <code>safe</code> filter (example: <code>{{ note | safe }}</code>). It's recommended to turn this option on for security reasons.
`;

// src/modal/collections.ts
var import_obsidian = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = /* @__PURE__ */ new Set();
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance3, create_fragment3, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment3 ? create_fragment3($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// src/modal/collections.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i][0];
  child_ctx[5] = list[i][1];
  child_ctx[6] = list;
  child_ctx[7] = i;
  return child_ctx;
}
function create_each_block(ctx) {
  let div;
  let input;
  let t0;
  let span;
  let t1_value = ctx[5].title + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function change_handler() {
    return ctx[2](ctx[5]);
  }
  function input_change_handler() {
    ctx[3].call(input, ctx[6], ctx[7]);
  }
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(input, "type", "checkbox");
      attr(div, "class", "collection-entry");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      input.checked = ctx[5].sync;
      append(div, t0);
      append(div, span);
      append(span, t1);
      append(div, t2);
      if (!mounted) {
        dispose = [
          listen(input, "change", change_handler),
          listen(input, "change", input_change_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1) {
        input.checked = ctx[5].sync;
      }
      if (dirty & 1 && t1_value !== (t1_value = ctx[5].title + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment(ctx) {
  let div;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { collections = [] } = $$props;
  let { toggle } = $$props;
  const change_handler = async (collection) => toggle(collection.id);
  function input_change_handler(each_value, each_index) {
    each_value[each_index][1].sync = this.checked;
    $$invalidate(0, collections);
  }
  $$self.$$set = ($$props2) => {
    if ("collections" in $$props2)
      $$invalidate(0, collections = $$props2.collections);
    if ("toggle" in $$props2)
      $$invalidate(1, toggle = $$props2.toggle);
  };
  return [collections, toggle, change_handler, input_change_handler];
}
var Collections = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { collections: 0, toggle: 1 });
  }
};
var collections_default = Collections;

// src/modal/collections.ts
var CollectionsModal = class extends import_obsidian.Modal {
  constructor(app2, plugin) {
    super(app2);
    this.plugin = plugin;
    this.open();
  }
  async onOpen() {
    super.onOpen();
    this.titleEl.innerText = "Raindrop.io: Manage collections to be synced";
    const collections = Object.entries(this.plugin.settings.syncCollections).sort((a, b) => {
      return a[1].title.localeCompare(b[1].title);
    });
    this.modalContent = new collections_default({
      target: this.contentEl,
      props: {
        collections,
        toggle: async (id) => {
          this.plugin.settings.syncCollections[id].sync = !this.plugin.settings.syncCollections[id].sync;
          await this.plugin.saveSettings();
        }
      }
    });
  }
  onClose() {
    super.onClose();
    this.modalContent.$destroy();
  }
};

// src/renderer.ts
var import_nunjucks = __toESM(require_nunjucks());
var import_moment = __toESM(require_moment());
var import_sanitize_filename = __toESM(require_sanitize_filename());
var import_obsidian2 = require("obsidian");
var FAKE_RENDER_CONTEXT = {
  is_new_article: true,
  id: 1e3,
  title: "fake_title",
  excerpt: "fake_excerpt",
  note: "fake_note",
  link: "https://example.com",
  highlights: [
    {
      id: "123456789abcdefghijklmno",
      color: "red",
      created: (0, import_moment.default)(),
      lastUpdate: (0, import_moment.default)(),
      note: "fake_note",
      text: "fake_text"
    }
  ],
  collection: {
    title: "fake_collection"
  },
  tags: ["fake_tag1", "fake_tag2"],
  cover: "https://example.com",
  created: (0, import_moment.default)(),
  type: "link",
  important: false,
  creator: {
    name: "fake_name",
    id: 1e4
  },
  now: (0, import_moment.default)()
};
var Renderer = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  validate(template, isYaml = false) {
    try {
      const env = this.createEnv();
      const fakeContent = env.renderString(template, FAKE_RENDER_CONTEXT);
      if (isYaml) {
        const { id } = FAKE_RENDER_CONTEXT;
        const fakeMetadata = `raindrop_id: ${id}
${fakeContent}`;
        (0, import_obsidian2.parseYaml)(fakeMetadata);
      }
      return true;
    } catch (error) {
      return false;
    }
  }
  renderContent(bookmark, newArticle) {
    return this.renderTemplate(this.plugin.settings.template, bookmark, newArticle);
  }
  renderFrontmatter(bookmark, newArticle) {
    const newMdFrontmatter = this.renderTemplate(this.plugin.settings.metadataTemplate, bookmark, newArticle);
    const frontmatterObj = {
      raindrop_id: bookmark.id
    };
    if (bookmark.highlights.length > 0) {
      frontmatterObj.raindrop_highlights = Object.fromEntries(bookmark.highlights.map((hl) => {
        return [hl.id, hl.signature];
      }));
    }
    if (newMdFrontmatter.length > 0) {
      return `${(0, import_obsidian2.stringifyYaml)(frontmatterObj)}${newMdFrontmatter}`;
    } else {
      return (0, import_obsidian2.stringifyYaml)(frontmatterObj);
    }
  }
  renderFullArticle(bookmark) {
    const newMdContent = this.renderContent(bookmark, true);
    const newMdFrontmatter = this.renderFrontmatter(bookmark, true);
    const mdContent = `---
${newMdFrontmatter}
---
${newMdContent}`;
    return mdContent;
  }
  renderFileName(bookmark, newArticle) {
    const filename = this.renderTemplate(this.plugin.settings.filenameTemplate, bookmark, newArticle);
    return this.sanitizeFilename(filename);
  }
  sanitizeFilename(filename) {
    return (0, import_sanitize_filename.default)(filename.replace(/[':#|]/g, "").trim());
  }
  renderTemplate(template, bookmark, newArticle) {
    const renderHighlights = bookmark.highlights.map((hl) => {
      const renderHighlight = {
        id: hl.id,
        color: hl.color,
        created: (0, import_moment.default)(hl.created),
        lastUpdate: (0, import_moment.default)(hl.lastUpdate),
        note: hl.note,
        text: hl.text
      };
      return renderHighlight;
    });
    const renderCollection = {
      title: this.plugin.settings.syncCollections[bookmark.collectionId].title
    };
    const context = {
      is_new_article: newArticle,
      id: bookmark.id,
      title: bookmark.title,
      excerpt: bookmark.excerpt,
      note: bookmark.note,
      link: bookmark.link,
      highlights: renderHighlights,
      collection: renderCollection,
      tags: bookmark.tags,
      cover: bookmark.cover,
      created: (0, import_moment.default)(bookmark.created),
      type: bookmark.type,
      important: bookmark.important,
      creator: bookmark.creator,
      now: (0, import_moment.default)()
    };
    const env = this.createEnv();
    const content = env.renderString(template, context);
    return content;
  }
  createEnv() {
    const env = new import_nunjucks.default.Environment(void 0, { autoescape: this.plugin.settings.autoescape });
    env.addFilter("date", (date, format) => {
      return date.format(format);
    });
    return env;
  }
};

// src/modal/apiTokenModal.ts
var import_obsidian3 = require("obsidian");

// src/modal/apiTokenModal.svelte
function create_fragment2(ctx) {
  let div3;
  let t5;
  let div4;
  let input;
  let t6;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      div3.innerHTML = `<div class="setting-item-info"><div class="setting-item-name">Raindrop.io API Token</div> 
		<div class="setting-item-description"><span>Log into your <a href="https://app.raindrop.io/settings/integrations">Developer Settings</a> to get your &quot;Test token&quot;.</span></div></div>`;
      t5 = space();
      div4 = element("div");
      input = element("input");
      t6 = space();
      button = element("button");
      button.textContent = "Save";
      attr(div3, "class", "setting-item");
      attr(input, "type", "text");
      attr(input, "placeholder", "API token");
      attr(input, "size", "40");
      attr(button, "class", "mod-cta");
      set_style(button, "float", "right");
      attr(div4, "class", "setting-item-info");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      insert(target, t5, anchor);
      insert(target, div4, anchor);
      append(div4, input);
      ctx[2](input);
      append(div4, t6);
      append(div4, button);
      if (!mounted) {
        dispose = listen(button, "click", ctx[3]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div3);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div4);
      ctx[2](null);
      mounted = false;
      dispose();
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { onSubmit } = $$props;
  let tokenInput;
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tokenInput = $$value;
      $$invalidate(1, tokenInput);
    });
  }
  const click_handler = () => onSubmit(tokenInput.value);
  $$self.$$set = ($$props2) => {
    if ("onSubmit" in $$props2)
      $$invalidate(0, onSubmit = $$props2.onSubmit);
  };
  return [onSubmit, tokenInput, input_binding, click_handler];
}
var ApiTokenModal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { onSubmit: 0 });
  }
};
var apiTokenModal_default = ApiTokenModal;

// src/modal/apiTokenModal.ts
var ApiTokenModal2 = class extends import_obsidian3.Modal {
  constructor(app2, api) {
    super(app2);
    this.api = api;
    this.waitForClose = new Promise((resolve) => this.resolvePromise = resolve);
    this.titleEl.innerText = "Enter Raindrop.io API token";
    this.modalContent = new apiTokenModal_default({
      target: this.contentEl,
      props: {
        onSubmit: async (value) => {
          try {
            await this.api.checkToken(value);
          } catch (e) {
            new import_obsidian3.Notice(e.message);
            return;
          }
          this.api.tokenManager.set(value);
          this.close();
        }
      }
    });
    this.open();
  }
  onClose() {
    super.onClose();
    this.modalContent.$destroy();
    this.resolvePromise();
  }
};

// src/settings.ts
var RaindropSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app2, plugin, api) {
    super(app2, plugin);
    this.plugin = plugin;
    this.renderer = new Renderer(plugin);
    this.api = api;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    if (this.plugin.settings.isConnected) {
      this.disconnect();
    } else {
      this.connect();
    }
    this.ribbonIcon();
    this.onlyBookmarksWithHl();
    this.appendMode();
    this.collectionsFolders();
    this.highlightsFolder();
    this.groups();
    this.collections();
    this.autoSyncInterval();
    this.autoSyncSuccessNotice();
    this.template();
    this.metadataTemplate();
    this.filenameTemplate();
    this.autoescape();
    this.resetSyncHistory();
  }
  ribbonIcon() {
    new import_obsidian4.Setting(this.containerEl).setName("Enable ribbon icon in the sidebar (need reload)").addToggle((toggle) => {
      return toggle.setValue(this.plugin.settings.ribbonIcon).onChange(async (value) => {
        this.plugin.settings.ribbonIcon = value;
        await this.plugin.saveSettings();
      });
    });
  }
  appendMode() {
    const descFragment = document.createRange().createContextualFragment(appendModeInstructions_default);
    new import_obsidian4.Setting(this.containerEl).setName("Append Mode").setDesc(descFragment).addToggle((toggle) => {
      return toggle.setValue(this.plugin.settings.appendMode).onChange(async (value) => {
        this.plugin.settings.appendMode = value;
        await this.plugin.saveSettings();
      });
    });
  }
  onlyBookmarksWithHl() {
    new import_obsidian4.Setting(this.containerEl).setName("Only sync bookmarks with highlights").addToggle((toggle) => {
      return toggle.setValue(this.plugin.settings.onlyBookmarksWithHl).onChange(async (value) => {
        this.plugin.settings.onlyBookmarksWithHl = value;
        await this.plugin.saveSettings();
      });
    });
  }
  collectionsFolders() {
    new import_obsidian4.Setting(this.containerEl).setName("Store the articles in collections folders").addToggle((toggle) => {
      return toggle.setValue(this.plugin.settings.collectionsFolders).onChange(async (value) => {
        this.plugin.settings.collectionsFolders = value;
        await this.plugin.saveSettings();
      });
    });
  }
  connect() {
    new import_obsidian4.Setting(this.containerEl).setName("Connect to Raindrop.io").addButton((button) => {
      return button.setButtonText("Connect").setCta().onClick(async () => {
        const tokenModal = new ApiTokenModal2(this.app, this.api);
        await tokenModal.waitForClose;
        if (this.api.tokenManager.get()) {
          new import_obsidian4.Notice("Token saved");
          const user = await this.api.getUser();
          this.plugin.settings.isConnected = true;
          this.plugin.settings.username = user.fullName;
          await this.plugin.saveSettings();
        }
        this.display();
      });
    });
  }
  async disconnect() {
    new import_obsidian4.Setting(this.containerEl).setName(`Connected to Raindrop.io as ${this.plugin.settings.username}`).addButton((button) => {
      return button.setButtonText("Test API").setCta().onClick(async () => {
        try {
          const user = await this.api.getUser();
          new import_obsidian4.Notice(`Test pass, hello ${user.fullName}`);
        } catch (e) {
          console.error(e);
          new import_obsidian4.Notice(`Test failed: ${e}`);
          this.api.tokenManager.clear();
          this.plugin.settings.isConnected = false;
          this.plugin.settings.username = void 0;
          await this.plugin.saveSettings();
        }
      });
    }).addButton((button) => {
      return button.setButtonText("Disconnect").setCta().onClick(async () => {
        button.removeCta().setButtonText("Removing API token...").setDisabled(true);
        try {
          this.api.tokenManager.clear();
          this.plugin.settings.isConnected = false;
          this.plugin.settings.username = void 0;
          await this.plugin.saveSettings();
        } catch (e) {
          console.error(e);
          new import_obsidian4.Notice(`Token removed failed: ${e}`);
          return;
        }
        new import_obsidian4.Notice("Token removed successfully");
        this.display();
      });
    });
  }
  highlightsFolder() {
    new import_obsidian4.Setting(this.containerEl).setName("Highlights folder location").setDesc("Vault folder to use for storing Raindrop.io highlights").addDropdown((dropdown) => {
      const files = this.app.vault.adapter.files;
      Object.keys(files).forEach((key) => {
        if (files[key].type == "folder") {
          const folder = files[key].realpath;
          dropdown.addOption(folder, folder);
        }
      });
      return dropdown.setValue(this.plugin.settings.highlightsFolder).onChange(async (value) => {
        this.plugin.settings.highlightsFolder = value;
        await this.plugin.saveSettings();
      });
    });
  }
  async groups() {
    const descFragment = document.createRange().createContextualFragment(collectionGroupsInstructions_default);
    new import_obsidian4.Setting(this.containerEl).setName("Collection groups").setDesc(descFragment).addToggle((toggle) => {
      return toggle.setValue(this.plugin.settings.collectionGroups).onChange(async (value) => {
        this.plugin.settings.collectionGroups = value;
        await this.plugin.saveSettings();
      });
    });
  }
  async collections() {
    new import_obsidian4.Setting(this.containerEl).setName("Collections").setDesc("Manage collections to be synced").addButton((button) => {
      return button.setDisabled(!this.plugin.settings.isConnected).setButtonText("Manage").setCta().onClick(async () => {
        button.setButtonText("Loading collections...");
        const collectionGroup = this.plugin.settings.collectionGroups;
        const allCollections = await this.api.getCollections(collectionGroup);
        this.plugin.updateCollectionSettings(allCollections);
        new CollectionsModal(this.app, this.plugin);
        this.display();
      });
    });
  }
  async template() {
    const templateDescFragment = document.createRange().createContextualFragment(templateInstructions_default);
    new import_obsidian4.Setting(this.containerEl).setName("Content template").setDesc(templateDescFragment).setClass("raindrop-content-template").addTextArea((text2) => {
      text2.setValue(this.plugin.settings.template).onChange(async (value) => {
        const isValid = this.renderer.validate(value);
        if (isValid) {
          this.plugin.settings.template = value;
          await this.plugin.saveSettings();
        }
        text2.inputEl.style.border = isValid ? "" : "1px solid red";
      });
      return text2;
    });
  }
  async metadataTemplate() {
    const templateDescFragment = document.createRange().createContextualFragment(metadataTemplateInstructions_default);
    new import_obsidian4.Setting(this.containerEl).setName("Metadata template").setDesc(templateDescFragment).setClass("raindrop-metadata-template").addTextArea((text2) => {
      text2.setPlaceholder(defaultMetadataTemplate_default);
      text2.setValue(this.plugin.settings.metadataTemplate).onChange(async (value) => {
        const isValid = this.renderer.validate(value, true);
        if (isValid) {
          this.plugin.settings.metadataTemplate = value;
          await this.plugin.saveSettings();
        }
        text2.inputEl.style.border = isValid ? "" : "1px solid red";
      });
      return text2;
    });
  }
  async filenameTemplate() {
    const templateDescFragment = document.createRange().createContextualFragment(filenameTemplateInstructions_default);
    new import_obsidian4.Setting(this.containerEl).setName("Filename template").setDesc(templateDescFragment).setClass("raindrop-filename-template").addTextArea((text2) => {
      text2.setValue(this.plugin.settings.filenameTemplate).onChange(async (value) => {
        const isValid = this.renderer.validate(value, false);
        if (isValid) {
          this.plugin.settings.filenameTemplate = value;
          await this.plugin.saveSettings();
        }
        text2.inputEl.style.border = isValid ? "" : "1px solid red";
      });
      return text2;
    });
  }
  resetSyncHistory() {
    new import_obsidian4.Setting(this.containerEl).setName("Reset the last sync time for each collection").setDesc("This is useful if you want to resync all bookmarks.").addButton((button) => {
      return button.setButtonText("Reset").setDisabled(!this.plugin.settings.isConnected).setWarning().onClick(async () => {
        for (const id in this.plugin.settings.syncCollections) {
          const collection = this.plugin.settings.syncCollections[id];
          collection.lastSyncDate = void 0;
        }
        this.plugin.saveSettings();
        new import_obsidian4.Notice("Sync history reset successfully");
      });
    });
  }
  autoSyncInterval() {
    new import_obsidian4.Setting(this.containerEl).setName("Auto sync in interval (minutes)").setDesc("Sync every X minutes. To disable auto sync, specify negative value or zero (default)").addText((text2) => {
      text2.setPlaceholder(String(0)).setValue(this.plugin.settings.autoSyncInterval.toString()).onChange(async (value) => {
        if (!isNaN(Number(value))) {
          const minutes = Number(value);
          this.plugin.settings.autoSyncInterval = minutes;
          await this.plugin.saveSettings();
          console.info("Set raindrop.io autosync interval", minutes);
          if (minutes > 0) {
            this.plugin.clearAutoSync();
            this.plugin.startAutoSync(minutes);
            console.info(`Raindrop.io auto sync enabled! Every ${minutes} minutes.`);
          } else {
            this.plugin.clearAutoSync();
            console.info("Raindrop.io auto sync disabled!");
          }
        }
      });
    });
  }
  autoSyncSuccessNotice() {
    new import_obsidian4.Setting(this.containerEl).setName("Display a notification when a collection is synced").addToggle((toggle) => {
      return toggle.setValue(this.plugin.settings.autoSyncSuccessNotice).onChange(async (value) => {
        this.plugin.settings.autoSyncSuccessNotice = value;
        await this.plugin.saveSettings();
      });
    });
  }
  autoescape() {
    const templateDescFragment = document.createRange().createContextualFragment(autoescapingInstructions_default);
    new import_obsidian4.Setting(this.containerEl).setName("Enable autoescaping for nunjucks").setDesc(templateDescFragment).addToggle((toggle) => {
      return toggle.setValue(this.plugin.settings.autoescape).onChange(async (value) => {
        this.plugin.settings.autoescape = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// src/sync.ts
var import_obsidian5 = require("obsidian");
var import_truncate_utf8_bytes = __toESM(require_browser2());
var RaindropSync = class {
  constructor(app2, plugin, api) {
    this.app = app2;
    this.api = api;
    this.plugin = plugin;
    this.renderer = new Renderer(plugin);
  }
  async sync() {
    const collectionGroup = this.plugin.settings.collectionGroups;
    const allCollections = await this.api.getCollections(collectionGroup);
    this.plugin.updateCollectionSettings(allCollections);
    for (const id in this.plugin.settings.syncCollections) {
      const collection = this.plugin.settings.syncCollections[id];
      if (collection.sync) {
        await this.syncCollection(collection);
      }
    }
  }
  async syncCollection(collection) {
    if (this.plugin.settings.autoSyncSuccessNotice) {
      new import_obsidian5.Notice(`Sync Raindrop collection: ${collection.title}`);
    }
    const highlightsFolder = this.plugin.settings.highlightsFolder;
    let collectionFolder = highlightsFolder;
    if (this.plugin.settings.collectionsFolders) {
      collectionFolder = `${highlightsFolder}/${collection["title"]}`;
    }
    const lastSyncDate = this.plugin.settings.syncCollections[collection.id].lastSyncDate;
    try {
      console.debug(`start sync collection: ${collection.title}, last sync at: ${lastSyncDate}`);
      for await (const bookmarks of this.api.getRaindropsAfter(collection.id, this.plugin.settings.autoSyncSuccessNotice, lastSyncDate)) {
        await this.syncBookmarks(bookmarks, collectionFolder);
      }
      await this.syncCollectionComplete(collection);
    } catch (e) {
      console.error(e);
      new import_obsidian5.Notice(`Sync Raindrop collection ${collection.title} failed: ${e.message}`);
    }
  }
  async syncBookmarks(bookmarks, folderPath) {
    if (bookmarks.length == 0)
      return;
    if (this.plugin.settings.onlyBookmarksWithHl) {
      const requireUpdate = bookmarks.some((bookmark) => {
        return bookmark.highlights.length != 0;
      });
      if (!requireUpdate)
        return;
    }
    try {
      await this.app.vault.createFolder(folderPath);
    } catch (e) {
    }
    const bookmarkFilesMap = Object.assign({}, ...this.getBookmarkFiles().map((x) => ({ [x.raindropId]: x.file })));
    for (const bookmark of bookmarks) {
      if (this.plugin.settings.onlyBookmarksWithHl && bookmark.highlights.length == 0) {
        continue;
      }
      if (bookmark.id in bookmarkFilesMap) {
        await this.updateFileContent(bookmarkFilesMap[bookmark.id], bookmark);
        await this.updateFileName(bookmarkFilesMap[bookmark.id], bookmark, folderPath);
      } else {
        const renderedFilename = this.renderer.renderFileName(bookmark, true);
        const filePath = await this.buildNonDupFilePath(folderPath, renderedFilename);
        bookmarkFilesMap[bookmark.id] = await this.createFile(filePath, bookmark);
      }
    }
  }
  buildFilePath(folderPath, renderedFilename, suffix) {
    let fileSuffix = ".md";
    let fileName = (0, import_truncate_utf8_bytes.default)(`${renderedFilename}`, 255 - fileSuffix.length) + fileSuffix;
    if (suffix) {
      fileSuffix = ` (${suffix++}).md`;
      fileName = (0, import_truncate_utf8_bytes.default)(`${renderedFilename}`, 255 - fileSuffix.length) + fileSuffix;
    }
    return (0, import_obsidian5.normalizePath)(`${folderPath}/${fileName}`);
  }
  async buildNonDupFilePath(folderPath, renderedFilename) {
    let filePath = this.buildFilePath(folderPath, renderedFilename);
    let suffix = 1;
    while (await this.app.vault.adapter.exists(filePath)) {
      console.debug(`${filePath} alreay exists`);
      filePath = this.buildFilePath(folderPath, renderedFilename, suffix++);
    }
    return filePath;
  }
  async syncCollectionComplete(collection) {
    this.plugin.settings.syncCollections[collection.id].lastSyncDate = new Date();
    await this.plugin.saveSettings();
  }
  async updateFileName(file, bookmark, folderPath) {
    const renderedFilename = this.renderer.renderFileName(bookmark, true);
    let newFilePath = this.buildFilePath(folderPath, renderedFilename);
    const newFileMeta = this.app.metadataCache.getCache(newFilePath);
    if ((newFileMeta == null ? void 0 : newFileMeta.frontmatter) && "raindrop_id" in newFileMeta.frontmatter && newFileMeta.frontmatter.raindrop_id == bookmark.id) {
      console.debug(`file name of "${file.path}" is not changed`);
      return;
    }
    newFilePath = await this.buildNonDupFilePath(folderPath, renderedFilename);
    console.debug(`file name change detected, rename "${file.path}" to "${newFilePath}"`);
    await this.app.fileManager.renameFile(file, newFilePath);
  }
  async updateFileContent(file, bookmark) {
    if (this.plugin.settings.appendMode) {
      await this.updateFileAppendMode(file, bookmark);
    } else {
      await this.updateFileOverwriteMode(file, bookmark);
    }
  }
  async updateFileAppendMode(file, bookmark) {
    console.debug(`update file append mode ${file.path}`);
    const metadata = this.app.metadataCache.getFileCache(file);
    const highlightSigs = Object.fromEntries(bookmark.highlights.map((hl) => [hl.id, hl.signature]));
    if ((metadata == null ? void 0 : metadata.frontmatter) && "raindrop_highlights" in metadata.frontmatter) {
      const localHighlights = metadata.frontmatter.raindrop_highlights;
      bookmark.highlights = bookmark.highlights.filter((hl) => {
        return !(hl.id in localHighlights && hl.signature === localHighlights[hl.id]);
      });
    }
    const appendedContent = this.renderer.renderContent(bookmark, false);
    await this.app.vault.append(file, appendedContent);
    const fileContent = await this.app.vault.cachedRead(file);
    const bookmarkFm = this.renderer.renderFrontmatter(bookmark, false);
    const bookmarkFmObj = (0, import_obsidian5.parseYaml)(bookmarkFm);
    bookmarkFmObj.raindrop_highlights = highlightSigs;
    if (metadata == null ? void 0 : metadata.frontmatterPosition) {
      const article = this.splitFrontmatterAndContent(fileContent, metadata.frontmatterPosition.end.line);
      const fileFmObj = (0, import_obsidian5.parseYaml)(article.frontmatter);
      const newFmObj = { ...fileFmObj, ...bookmarkFmObj };
      if (Object.keys(highlightSigs).length == 0 && "raindrop_highlights" in newFmObj) {
        delete newFmObj["raindrop_highlights"];
      }
      const newFrontmatter = (0, import_obsidian5.stringifyYaml)(newFmObj);
      const newFullFileContent = `---
${newFrontmatter}---
${article.content}`;
      await this.app.vault.modify(file, newFullFileContent);
    } else {
      if (Object.keys(highlightSigs).length == 0 && "raindrop_highlights" in bookmarkFmObj) {
        delete bookmarkFmObj["raindrop_highlights"];
      }
      const newFrontmatter = (0, import_obsidian5.stringifyYaml)(bookmarkFmObj);
      const newFullFileContent = `---
${newFrontmatter}---
${fileContent}`;
      await this.app.vault.modify(file, newFullFileContent);
    }
  }
  async updateFileOverwriteMode(file, bookmark) {
    console.debug("update file overwrite mode", file.path);
    const mdContent = this.renderer.renderFullArticle(bookmark);
    return this.app.vault.modify(file, mdContent);
  }
  async createFile(filePath, bookmark) {
    console.debug("create file", filePath);
    const mdContent = this.renderer.renderFullArticle(bookmark);
    return this.app.vault.create(filePath, mdContent);
  }
  getBookmarkFiles() {
    return this.app.vault.getMarkdownFiles().map((file) => {
      var _a;
      const cache = this.app.metadataCache.getFileCache(file);
      const raindropId = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.raindrop_id;
      return { file, raindropId };
    }).filter(({ raindropId }) => {
      return raindropId;
    });
  }
  splitFrontmatterAndContent(content, fmEndLine) {
    let splitPosFm = -1;
    while (fmEndLine-- && splitPosFm++ < content.length) {
      splitPosFm = content.indexOf("\n", splitPosFm);
      if (splitPosFm < 0)
        throw Error("Split front matter failed");
    }
    let splitPosContent = splitPosFm + 1;
    splitPosContent = content.indexOf("\n", splitPosContent) + 1;
    return {
      content: content.substring(splitPosContent),
      frontmatter: content.substring(0, splitPosFm)
    };
  }
};

// src/api.ts
var import_obsidian6 = require("obsidian");
var import_axios = __toESM(require_axios2());

// node_modules/axios-retry/lib/esm/index.js
var import_is_retry_allowed = __toESM(require_is_retry_allowed(), 1);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var namespace = "axios-retry";
function isNetworkError(error) {
  var CODE_EXCLUDE_LIST = ["ERR_CANCELED", "ECONNABORTED"];
  return !error.response && Boolean(error.code) && !CODE_EXCLUDE_LIST.includes(error.code) && (0, import_is_retry_allowed.default)(error);
}
var SAFE_HTTP_METHODS = ["get", "head", "options"];
var IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(["put", "delete"]);
function isRetryableError(error) {
  return error.code !== "ECONNABORTED" && (!error.response || error.response.status >= 500 && error.response.status <= 599);
}
function isSafeRequestError(error) {
  if (!error.config) {
    return false;
  }
  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;
}
function isIdempotentRequestError(error) {
  if (!error.config) {
    return false;
  }
  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;
}
function isNetworkOrIdempotentRequestError(error) {
  return isNetworkError(error) || isIdempotentRequestError(error);
}
function noDelay() {
  return 0;
}
function exponentialDelay() {
  var retryNumber = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var error = arguments.length > 1 ? arguments[1] : void 0;
  var delayFactor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 100;
  var delay = Math.pow(2, retryNumber) * delayFactor;
  var randomSum = delay * 0.2 * Math.random();
  return delay + randomSum;
}
function getCurrentState(config) {
  var currentState = config[namespace] || {};
  currentState.retryCount = currentState.retryCount || 0;
  config[namespace] = currentState;
  return currentState;
}
function getRequestOptions(config, defaultOptions) {
  return _objectSpread(_objectSpread({}, defaultOptions), config[namespace]);
}
function fixConfig(axios2, config) {
  if (axios2.defaults.agent === config.agent) {
    delete config.agent;
  }
  if (axios2.defaults.httpAgent === config.httpAgent) {
    delete config.httpAgent;
  }
  if (axios2.defaults.httpsAgent === config.httpsAgent) {
    delete config.httpsAgent;
  }
}
function shouldRetry(_x, _x2, _x3, _x4) {
  return _shouldRetry.apply(this, arguments);
}
function _shouldRetry() {
  _shouldRetry = _asyncToGenerator(function* (retries, retryCondition, currentState, error) {
    var shouldRetryOrPromise = currentState.retryCount < retries && retryCondition(error);
    if (typeof shouldRetryOrPromise === "object") {
      try {
        var shouldRetryPromiseResult = yield shouldRetryOrPromise;
        return shouldRetryPromiseResult !== false;
      } catch (_err) {
        return false;
      }
    }
    return shouldRetryOrPromise;
  });
  return _shouldRetry.apply(this, arguments);
}
function axiosRetry(axios2, defaultOptions) {
  var requestInterceptorId = axios2.interceptors.request.use((config) => {
    var currentState = getCurrentState(config);
    currentState.lastRequestTime = Date.now();
    return config;
  });
  var responseInterceptorId = axios2.interceptors.response.use(null, /* @__PURE__ */ function() {
    var _ref = _asyncToGenerator(function* (error) {
      var {
        config
      } = error;
      if (!config) {
        return Promise.reject(error);
      }
      var {
        retries = 3,
        retryCondition = isNetworkOrIdempotentRequestError,
        retryDelay = noDelay,
        shouldResetTimeout = false,
        onRetry = () => {
        }
      } = getRequestOptions(config, defaultOptions);
      var currentState = getCurrentState(config);
      if (yield shouldRetry(retries, retryCondition, currentState, error)) {
        currentState.retryCount += 1;
        var delay = retryDelay(currentState.retryCount, error);
        fixConfig(axios2, config);
        if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {
          var lastRequestDuration = Date.now() - currentState.lastRequestTime;
          var timeout = config.timeout - lastRequestDuration - delay;
          if (timeout <= 0) {
            return Promise.reject(error);
          }
          config.timeout = timeout;
        }
        config.transformRequest = [(data) => data];
        onRetry(currentState.retryCount, error, config);
        return new Promise((resolve) => setTimeout(() => resolve(axios2(config)), delay));
      }
      return Promise.reject(error);
    });
    return function(_x5) {
      return _ref.apply(this, arguments);
    };
  }());
  return {
    requestInterceptorId,
    responseInterceptorId
  };
}
axiosRetry.isNetworkError = isNetworkError;
axiosRetry.isSafeRequestError = isSafeRequestError;
axiosRetry.isIdempotentRequestError = isIdempotentRequestError;
axiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
axiosRetry.exponentialDelay = exponentialDelay;
axiosRetry.isRetryableError = isRetryableError;

// src/tokenManager.ts
var TokenManager = class {
  get() {
    const token = window.localStorage.getItem("raindrop_token");
    if (token === null || token.length == 0) {
      return null;
    }
    return token;
  }
  set(token) {
    window.localStorage.setItem("raindrop_token", token);
  }
  clear() {
    window.localStorage.removeItem("raindrop_token");
  }
};

// node_modules/ts-md5/dist/esm/md5.js
var Md5 = class {
  constructor() {
    this._dataLength = 0;
    this._bufferLength = 0;
    this._state = new Int32Array(4);
    this._buffer = new ArrayBuffer(68);
    this._buffer8 = new Uint8Array(this._buffer, 0, 68);
    this._buffer32 = new Uint32Array(this._buffer, 0, 17);
    this.start();
  }
  static hashStr(str, raw = false) {
    return this.onePassHasher.start().appendStr(str).end(raw);
  }
  static hashAsciiStr(str, raw = false) {
    return this.onePassHasher.start().appendAsciiStr(str).end(raw);
  }
  static _hex(x) {
    const hc = Md5.hexChars;
    const ho = Md5.hexOut;
    let n;
    let offset;
    let j;
    let i;
    for (i = 0; i < 4; i += 1) {
      offset = i * 8;
      n = x[i];
      for (j = 0; j < 8; j += 2) {
        ho[offset + 1 + j] = hc.charAt(n & 15);
        n >>>= 4;
        ho[offset + 0 + j] = hc.charAt(n & 15);
        n >>>= 4;
      }
    }
    return ho.join("");
  }
  static _md5cycle(x, k) {
    let a = x[0];
    let b = x[1];
    let c = x[2];
    let d = x[3];
    a += (b & c | ~b & d) + k[0] - 680876936 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[1] - 389564586 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[2] + 606105819 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
    b = (b << 22 | b >>> 10) + c | 0;
    a += (b & c | ~b & d) + k[4] - 176418897 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[7] - 45705983 | 0;
    b = (b << 22 | b >>> 10) + c | 0;
    a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[10] - 42063 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
    b = (b << 22 | b >>> 10) + c | 0;
    a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
    a = (a << 7 | a >>> 25) + b | 0;
    d += (a & b | ~a & c) + k[13] - 40341101 | 0;
    d = (d << 12 | d >>> 20) + a | 0;
    c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
    c = (c << 17 | c >>> 15) + d | 0;
    b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
    b = (b << 22 | b >>> 10) + c | 0;
    a += (b & d | c & ~d) + k[1] - 165796510 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[11] + 643717713 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[0] - 373897302 | 0;
    b = (b << 20 | b >>> 12) + c | 0;
    a += (b & d | c & ~d) + k[5] - 701558691 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[10] + 38016083 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[15] - 660478335 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[4] - 405537848 | 0;
    b = (b << 20 | b >>> 12) + c | 0;
    a += (b & d | c & ~d) + k[9] + 568446438 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[3] - 187363961 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
    b = (b << 20 | b >>> 12) + c | 0;
    a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
    a = (a << 5 | a >>> 27) + b | 0;
    d += (a & c | b & ~c) + k[2] - 51403784 | 0;
    d = (d << 9 | d >>> 23) + a | 0;
    c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
    c = (c << 14 | c >>> 18) + d | 0;
    b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
    b = (b << 20 | b >>> 12) + c | 0;
    a += (b ^ c ^ d) + k[5] - 378558 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[14] - 35309556 | 0;
    b = (b << 23 | b >>> 9) + c | 0;
    a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[7] - 155497632 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
    b = (b << 23 | b >>> 9) + c | 0;
    a += (b ^ c ^ d) + k[13] + 681279174 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[0] - 358537222 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[3] - 722521979 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[6] + 76029189 | 0;
    b = (b << 23 | b >>> 9) + c | 0;
    a += (b ^ c ^ d) + k[9] - 640364487 | 0;
    a = (a << 4 | a >>> 28) + b | 0;
    d += (a ^ b ^ c) + k[12] - 421815835 | 0;
    d = (d << 11 | d >>> 21) + a | 0;
    c += (d ^ a ^ b) + k[15] + 530742520 | 0;
    c = (c << 16 | c >>> 16) + d | 0;
    b += (c ^ d ^ a) + k[2] - 995338651 | 0;
    b = (b << 23 | b >>> 9) + c | 0;
    a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
    b = (b << 21 | b >>> 11) + c | 0;
    a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
    b = (b << 21 | b >>> 11) + c | 0;
    a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
    b = (b << 21 | b >>> 11) + c | 0;
    a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
    a = (a << 6 | a >>> 26) + b | 0;
    d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
    d = (d << 10 | d >>> 22) + a | 0;
    c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
    c = (c << 15 | c >>> 17) + d | 0;
    b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
    b = (b << 21 | b >>> 11) + c | 0;
    x[0] = a + x[0] | 0;
    x[1] = b + x[1] | 0;
    x[2] = c + x[2] | 0;
    x[3] = d + x[3] | 0;
  }
  start() {
    this._dataLength = 0;
    this._bufferLength = 0;
    this._state.set(Md5.stateIdentity);
    return this;
  }
  appendStr(str) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let code;
    let i;
    for (i = 0; i < str.length; i += 1) {
      code = str.charCodeAt(i);
      if (code < 128) {
        buf8[bufLen++] = code;
      } else if (code < 2048) {
        buf8[bufLen++] = (code >>> 6) + 192;
        buf8[bufLen++] = code & 63 | 128;
      } else if (code < 55296 || code > 56319) {
        buf8[bufLen++] = (code >>> 12) + 224;
        buf8[bufLen++] = code >>> 6 & 63 | 128;
        buf8[bufLen++] = code & 63 | 128;
      } else {
        code = (code - 55296) * 1024 + (str.charCodeAt(++i) - 56320) + 65536;
        if (code > 1114111) {
          throw new Error("Unicode standard supports code points up to U+10FFFF");
        }
        buf8[bufLen++] = (code >>> 18) + 240;
        buf8[bufLen++] = code >>> 12 & 63 | 128;
        buf8[bufLen++] = code >>> 6 & 63 | 128;
        buf8[bufLen++] = code & 63 | 128;
      }
      if (bufLen >= 64) {
        this._dataLength += 64;
        Md5._md5cycle(this._state, buf32);
        bufLen -= 64;
        buf32[0] = buf32[16];
      }
    }
    this._bufferLength = bufLen;
    return this;
  }
  appendAsciiStr(str) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let i;
    let j = 0;
    for (; ; ) {
      i = Math.min(str.length - j, 64 - bufLen);
      while (i--) {
        buf8[bufLen++] = str.charCodeAt(j++);
      }
      if (bufLen < 64) {
        break;
      }
      this._dataLength += 64;
      Md5._md5cycle(this._state, buf32);
      bufLen = 0;
    }
    this._bufferLength = bufLen;
    return this;
  }
  appendByteArray(input) {
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    let bufLen = this._bufferLength;
    let i;
    let j = 0;
    for (; ; ) {
      i = Math.min(input.length - j, 64 - bufLen);
      while (i--) {
        buf8[bufLen++] = input[j++];
      }
      if (bufLen < 64) {
        break;
      }
      this._dataLength += 64;
      Md5._md5cycle(this._state, buf32);
      bufLen = 0;
    }
    this._bufferLength = bufLen;
    return this;
  }
  getState() {
    const s = this._state;
    return {
      buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)),
      buflen: this._bufferLength,
      length: this._dataLength,
      state: [s[0], s[1], s[2], s[3]]
    };
  }
  setState(state) {
    const buf = state.buffer;
    const x = state.state;
    const s = this._state;
    let i;
    this._dataLength = state.length;
    this._bufferLength = state.buflen;
    s[0] = x[0];
    s[1] = x[1];
    s[2] = x[2];
    s[3] = x[3];
    for (i = 0; i < buf.length; i += 1) {
      this._buffer8[i] = buf.charCodeAt(i);
    }
  }
  end(raw = false) {
    const bufLen = this._bufferLength;
    const buf8 = this._buffer8;
    const buf32 = this._buffer32;
    const i = (bufLen >> 2) + 1;
    this._dataLength += bufLen;
    const dataBitsLen = this._dataLength * 8;
    buf8[bufLen] = 128;
    buf8[bufLen + 1] = buf8[bufLen + 2] = buf8[bufLen + 3] = 0;
    buf32.set(Md5.buffer32Identity.subarray(i), i);
    if (bufLen > 55) {
      Md5._md5cycle(this._state, buf32);
      buf32.set(Md5.buffer32Identity);
    }
    if (dataBitsLen <= 4294967295) {
      buf32[14] = dataBitsLen;
    } else {
      const matches = dataBitsLen.toString(16).match(/(.*?)(.{0,8})$/);
      if (matches === null) {
        return;
      }
      const lo = parseInt(matches[2], 16);
      const hi = parseInt(matches[1], 16) || 0;
      buf32[14] = lo;
      buf32[15] = hi;
    }
    Md5._md5cycle(this._state, buf32);
    return raw ? this._state : Md5._hex(this._state);
  }
};
Md5.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]);
Md5.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
Md5.hexChars = "0123456789abcdef";
Md5.hexOut = [];
Md5.onePassHasher = new Md5();
if (Md5.hashStr("hello") !== "5d41402abc4b2a76b9719d911017c592") {
  throw new Error("Md5 self test failed.");
}

// src/api.ts
var BASEURL = "https://api.raindrop.io/rest/v1";
axiosRetry(import_axios.default, {
  retries: 3,
  retryCondition: (error) => {
    if (error.response && error.response.status === 429) {
      new import_obsidian6.Notice("Too many requests, will retry sync after 1 minute", 5);
      console.warn(`Too many requests, will retry sync after 1 minute`);
      return true;
    } else {
      console.error(`request error: ${error}`);
    }
    return false;
  },
  retryDelay: () => {
    return 6e4;
  },
  onRetry: (retryCount) => {
    new import_obsidian6.Notice(`Retry sync ${retryCount}/3`);
  }
});
var RaindropAPI = class {
  constructor(app2) {
    this.app = app2;
    this.tokenManager = new TokenManager();
  }
  async get(url, params) {
    const token = this.tokenManager.get();
    if (!token) {
      throw new Error("Invalid token");
    }
    const result = await import_axios.default.get(url, {
      params,
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json"
      }
    });
    if (result.status == 401) {
      throw new Error("Unauthorized");
    }
    if (result.status !== 200) {
      console.error("Raindrop API request failed:", result);
      throw new Error("Request failed");
    }
    return result.data;
  }
  async getCollections(enableCollectionGroup) {
    const rootCollectionPromise = this.get(`${BASEURL}/collections`, {});
    const nestedCollectionPromise = this.get(`${BASEURL}/collections/childrens`, {});
    const collections = [
      { id: -1, title: "Unsorted" },
      { id: 0, title: "All bookmarks" },
      { id: -99, title: "Trash" }
    ];
    const collectionGroupMap = {};
    if (enableCollectionGroup) {
      const res = await this.get(`${BASEURL}/user`, {});
      const groups = this.parseGroups(res.user.groups);
      groups.forEach((g) => {
        g.collections.forEach((cid) => {
          collectionGroupMap[cid] = g.title;
        });
      });
    }
    const rootCollectionMap = {};
    const rootCollections = await rootCollectionPromise;
    rootCollections.items.forEach((collection) => {
      const id = collection["_id"];
      let title = collection["title"];
      if (enableCollectionGroup) {
        title = `${collectionGroupMap[id]}/${title}`;
      }
      rootCollectionMap[id] = title;
      collections.push({
        title,
        id
      });
    });
    const nestedCollectionMap = {};
    const nestedCollections = await nestedCollectionPromise;
    nestedCollections.items.forEach((collection) => {
      const id = collection["_id"];
      nestedCollectionMap[id] = {
        title: collection["title"],
        parentId: collection["parent"]["$id"]
      };
    });
    nestedCollections.items.forEach((collection) => {
      const id = collection["_id"];
      let parentId = collection["parent"]["$id"];
      let title = collection["title"];
      while (parentId && parentId in nestedCollectionMap) {
        title = `${nestedCollectionMap[parentId].title}/${title}`;
        parentId = nestedCollectionMap[parentId].parentId;
      }
      if (parentId && parentId in rootCollectionMap) {
        title = `${rootCollectionMap[parentId]}/${title}`;
      }
      collections.push({
        title,
        id
      });
    });
    return collections;
  }
  async *getRaindropsAfter(collectionId, showNotice, lastSync) {
    let notice;
    if (showNotice) {
      notice = new import_obsidian6.Notice("Fetch Raindrops highlights", 0);
    }
    const pageSize = 50;
    const res = await this.get(`${BASEURL}/raindrops/${collectionId}`, {
      page: 0,
      perpage: pageSize,
      sort: "-lastUpdate"
    });
    const raindropsCnt = res.count;
    let bookmarks = this.parseRaindrops(res.items);
    const totalPages = Math.ceil(raindropsCnt / pageSize);
    let remainPages = totalPages - 1;
    let page = 1;
    const getPage = async (page2) => {
      const res2 = await this.get(`${BASEURL}/raindrops/${collectionId}`, {
        page: page2,
        perpage: pageSize,
        sort: "-lastUpdate"
      });
      return this.parseRaindrops(res2.items);
    };
    if (lastSync === void 0) {
      if (bookmarks.length > 0) {
        yield bookmarks;
        while (remainPages--) {
          notice == null ? void 0 : notice.setMessage(`Sync Raindrop pages: ${page + 1}/${totalPages}`);
          yield await getPage(page++);
        }
      }
    } else {
      const filterLastUpdate = (bookmarks2) => {
        return bookmarks2.filter((bookmark) => {
          return bookmark.lastUpdate.getTime() >= lastSync.getTime();
        });
      };
      const filteredBookmark = filterLastUpdate(bookmarks);
      if (filteredBookmark.length > 0) {
        yield filteredBookmark;
        while (bookmarks[bookmarks.length - 1].lastUpdate.getTime() >= lastSync.getTime() && remainPages--) {
          notice == null ? void 0 : notice.setMessage(`Sync Raindrop pages: ${page + 1}/${totalPages}`);
          let bookmarks2 = await getPage(page++);
          yield filterLastUpdate(bookmarks2);
        }
      }
    }
    notice == null ? void 0 : notice.hide();
  }
  async getUser() {
    const res = await this.get(`${BASEURL}/user`, {});
    return {
      fullName: res.user.fullName
    };
  }
  async checkToken(token) {
    let result;
    try {
      result = await import_axios.default.get(`${BASEURL}/user`, {
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json"
        }
      });
      if (result.status !== 200) {
        throw new Error("Invalid token");
      }
    } catch (e) {
      throw new Error("Invalid token");
    }
    const user = result.data.user;
    return {
      fullName: user.fullName
    };
  }
  async getRaindrop(id) {
    const res = await this.get(`${BASEURL}/raindrop/${id}`, {});
    const bookmark = this.parseRaindrop(res.item);
    return bookmark;
  }
  parseRaindrops(bookmarks) {
    return bookmarks.map((raindrop) => {
      return this.parseRaindrop(raindrop);
    });
  }
  parseRaindrop(raindrop) {
    const bookmark = {
      id: raindrop["_id"],
      collectionId: raindrop["collectionId"],
      title: raindrop["title"],
      highlights: this.parseHighlights(raindrop["highlights"]),
      excerpt: raindrop["excerpt"],
      note: raindrop["note"],
      link: raindrop["link"],
      lastUpdate: new Date(raindrop["lastUpdate"]),
      tags: raindrop["tags"],
      cover: raindrop["cover"],
      created: new Date(raindrop["created"]),
      type: raindrop["type"],
      important: raindrop["important"],
      creator: {
        name: raindrop["creatorRef"]["name"],
        id: raindrop["creatorRef"]["_id"]
      }
    };
    return bookmark;
  }
  parseHighlights(highlights) {
    return highlights.map((hl) => {
      const highlight = {
        id: hl["_id"],
        color: hl["color"],
        text: hl["text"],
        lastUpdate: new Date(hl["lastUpdate"]),
        created: new Date(hl["created"]),
        note: hl["note"],
        signature: Md5.hashStr(`${hl["color"]},${hl["text"]},${hl["note"]}`)
      };
      return highlight;
    });
  }
  parseGroups(groups) {
    return groups.map((g) => {
      const group = {
        title: g["title"],
        collections: g["collections"]
      };
      return group;
    });
  }
};

// src/assets/defaultTemplate.njk
var defaultTemplate_default = '{% if is_new_article %}\n# Metadata\n{% if link %}Source URL:: {{link}}{% endif %}\n{% if tags|length %}Topics:: #{{ tags | join(", #") }}{% endif %}\n\n---\n# {{title}}\n\n{% if excerpt %}{{excerpt}}{% endif %}\n\n## Highlights\n{% endif -%}{% for highlight in highlights %}\n{% if highlight.color == "red" -%}\n    {%- set callout = "danger" -%}\n{%- elif highlight.color == "blue" -%}\n    {%- set callout = "info" -%}\n{%- elif highlight.color == "green" -%}\n    {%- set callout = "check" -%}\n{%- else -%}\n    {%- set callout = "quote" -%}\n{%- endif -%}\n> [!{{callout}}]+ Updated on {{highlight.lastUpdate}}\n>\n> {{highlight.text.split("\\n") | join("\\n>")}}\n{% if highlight.note -%}> > {{highlight.note + "\\n"}}{%- endif %}\n\n{%- endfor -%}\n';

// src/constants.ts
var VERSION = "0.0.20";
var DEFAULT_SETTINGS = {
  version: VERSION,
  username: void 0,
  isConnected: false,
  ribbonIcon: true,
  appendMode: true,
  collectionsFolders: true,
  onlyBookmarksWithHl: false,
  highlightsFolder: "/",
  collectionGroups: false,
  autoSyncSuccessNotice: true,
  syncCollections: {},
  template: defaultTemplate_default,
  metadataTemplate: "",
  filenameTemplate: "{{title}}",
  autoSyncInterval: 0,
  autoescape: true
};

// src/modal/breakingChange.ts
var import_obsidian7 = require("obsidian");
var import_semver = __toESM(require_semver2());
var BreadkingChangeModal = class extends import_obsidian7.Modal {
  constructor(app2, currentVersion) {
    super(app2);
    this.waitForClose = new Promise((resolve) => this.resolvePromise = resolve);
    this.titleEl.innerText = "Raindrop Highlight - Breaking Changes";
    let breakingChanges = "";
    if (import_semver.default.lt(currentVersion, "0.0.19")) {
      breakingChanges += `<p>v0.0.19</p>
<ul>
<li>The front matter property <code>raindrop_last_update</code> has now been replaced by <code>raindrop_highlights</code>, which stores the highlight signature for each highlight entry to fix the duplicate highlight entry bug in append mode.</li>
<li>The file name and front matter are now synced with templates while performing updates.</li>
</ul>
`;
    }
    if (import_semver.default.lt(currentVersion, "0.0.18")) {
      breakingChanges += `<p>v0.0.18</p>
<ul>
<li>Date &amp; time format field is replaced by the <code>date</code> filter in template. Update <code>created</code> and <code>lastUpdate</code> in template accordingly.</li>
</ul>
`;
    }
    if (breakingChanges !== "") {
      this.contentEl.innerHTML = breakingChanges;
      this.open();
    }
  }
  onClose() {
    super.onClose();
    this.resolvePromise();
  }
};

// src/main.ts
var import_semver2 = __toESM(require_semver2());
var RaindropPlugin = class extends import_obsidian8.Plugin {
  async onload() {
    await this.loadSettings();
    this.api = new RaindropAPI(this.app);
    this.raindropSync = new RaindropSync(this.app, this, this.api);
    if (this.settings.ribbonIcon) {
      this.addRibbonIcon("cloud", "Sync your Raindrop highlights", () => {
        if (!this.settings.isConnected) {
          new import_obsidian8.Notice("Please configure Raindrop API token in the plugin setting");
        } else {
          this.raindropSync.sync();
        }
      });
    }
    this.addCommand({
      id: "raindrop-sync",
      name: "Sync highlights",
      callback: async () => {
        await this.raindropSync.sync();
      }
    });
    this.addCommand({
      id: "raindrop-show-last-sync-time",
      name: "Show last sync time",
      callback: async () => {
        const message = Object.values(this.settings.syncCollections).filter((collection) => collection.sync).map((collection) => {
          var _a;
          return `${collection.title}: ${(_a = collection.lastSyncDate) == null ? void 0 : _a.toLocaleString()}`;
        }).join("\n");
        new import_obsidian8.Notice(message);
      }
    });
    this.addCommand({
      id: "raindrop-open-link",
      name: "Open link in Raindrop",
      callback: async () => {
        var _a;
        const file = app.workspace.getActiveFile();
        if (file) {
          const fmc = (_a = app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
          if (fmc == null ? void 0 : fmc.raindrop_id) {
            const bookmark = await this.api.getRaindrop(fmc.raindrop_id);
            window.open(`https://app.raindrop.io/my/${bookmark.collectionId}/item/${bookmark.id}/edit`);
          } else {
            new import_obsidian8.Notice("This is not a Raindrop article file");
          }
        } else {
          new import_obsidian8.Notice("No active file");
        }
      }
    });
    this.addCommand({
      id: "raindrop-manage-collection",
      name: "Manage collections to be synced",
      callback: async () => {
        const notice = new import_obsidian8.Notice("Loading collections...");
        const collectionGroup = this.settings.collectionGroups;
        const allCollections = await this.api.getCollections(collectionGroup);
        this.updateCollectionSettings(allCollections);
        notice.hide();
        new CollectionsModal(this.app, this);
      }
    });
    this.addSettingTab(new RaindropSettingTab(this.app, this, this.api));
    if (this.settings.autoSyncInterval) {
      await this.startAutoSync();
    }
  }
  async onunload() {
    await this.clearAutoSync();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    for (const id in this.settings.syncCollections) {
      const collection = this.settings.syncCollections[id];
      if (collection.lastSyncDate) {
        collection.lastSyncDate = new Date(collection.lastSyncDate);
      }
    }
    new BreadkingChangeModal(this.app, this.settings.version);
    if (import_semver2.default.lt(this.settings.version, "0.0.18")) {
      if ("dateTimeFormat" in this.settings) {
        delete this.settings["dateTimeFormat"];
      }
    }
    this.settings.version = VERSION;
    await this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async updateCollectionSettings(collections) {
    const syncCollections = {};
    collections.forEach(async (collection) => {
      const { id, title } = collection;
      if (!(id in this.settings.syncCollections)) {
        syncCollections[id] = {
          id,
          title,
          sync: false,
          lastSyncDate: void 0
        };
      } else {
        syncCollections[id] = this.settings.syncCollections[id];
        syncCollections[id].title = title;
      }
    });
    this.settings.syncCollections = syncCollections;
    await this.saveSettings();
  }
  async clearAutoSync() {
    if (this.timeoutIDAutoSync) {
      window.clearTimeout(this.timeoutIDAutoSync);
      this.timeoutIDAutoSync = void 0;
    }
    console.info("Clearing auto sync...");
  }
  async startAutoSync(minutes) {
    const minutesToSync = minutes != null ? minutes : this.settings.autoSyncInterval;
    if (minutesToSync > 0) {
      this.timeoutIDAutoSync = window.setTimeout(() => {
        this.raindropSync.sync();
        this.startAutoSync();
      }, minutesToSync * 6e4);
    }
    console.info(`StartAutoSync: this.timeoutIDAutoSync ${this.timeoutIDAutoSync} with ${minutesToSync} minutes`);
  }
};
/*! Browser bundle of nunjucks 3.2.4  */
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! moment.js
//! momentjs.com
//! version : 2.29.4
